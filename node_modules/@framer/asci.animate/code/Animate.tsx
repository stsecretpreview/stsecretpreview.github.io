import * as React from "react";
import { Size, PropertyControls, ControlType, RenderTarget } from "framer";

const style: React.CSSProperties = {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",

  height: "100%",
  color: "#8855FF",
  background: "transparent",
  overflow: "hidden"
};

// Define type of property
interface Props extends Size {
  delay: number;
  rotateStart: number;
  rotateEnd: number;
  transformOrigin: boolean;
  transformOriginXType: "%" | "px";
  transformOriginXPixels: number;
  transformOriginXPercent: number;
  transformOriginYType: "%" | "px";
  transformOriginYPixels: number;
  transformOriginYPercent: number;
  duration: number;
  target:
    | "top"
    | "left"
    | "right"
    | "bottom"
    | "opacity"
    | "rotate"
    | "scale"
    | "scaleX"
    | "scaleY";
  trigger: "mount" | "tap";
  easing:
    | "linear"
    | "ease"
    | "ease-in"
    | "ease-out"
    | "ease-in-out"
    | "ease-in-quad"
    | "ease-in-cubic"
    | "ease-in-quart"
    | "ease-in-quint"
    | "ease-in-sine"
    | "ease-in-expo"
    | "ease-in-circ"
    | "ease-in-back"
    | "ease-out-quad"
    | "ease-out-cubic"
    | "ease-out-quart"
    | "ease-out-quint"
    | "ease-out-sine"
    | "ease-out-expo"
    | "ease-out-circ"
    | "ease-out-back"
    | "ease-in-out-quad"
    | "ease-in-out-cubic"
    | "ease-in-out-quart"
    | "ease-in-out-quint"
    | "ease-in-out-sine"
    | "ease-in-out-expo"
    | "ease-in-out-circ"
    | "ease-in-out-back";
}

interface State {
  finished: boolean;
}

const cubicMap = {
  "ease-in-quad": "cubic-bezier(0.550, 0.085, 0.680, 0.530)",
  "ease-in-cubic": "cubic-bezier(0.550, 0.055, 0.675, 0.190)",
  "ease-in-quart": "cubic-bezier(0.895, 0.030, 0.685, 0.220)",
  "ease-in-quint": "cubic-bezier(0.755, 0.050, 0.855, 0.060)",
  "ease-in-sine": "cubic-bezier(0.470, 0.000, 0.745, 0.715)",
  "ease-in-expo": "cubic-bezier(0.950, 0.050, 0.795, 0.035)",
  "ease-in-circ": "cubic-bezier(0.600, 0.040, 0.980, 0.335)",
  "ease-in-back": "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
  "ease-out-quad": "cubic-bezier(0.250, 0.460, 0.450, 0.940)",
  "ease-out-cubic": "cubic-bezier(0.215, 0.610, 0.355, 1.000)",
  "ease-out-quart": "cubic-bezier(0.165, 0.840, 0.440, 1.000)",
  "ease-out-quint": "cubic-bezier(0.230, 1.000, 0.320, 1.000)",
  "ease-out-sine": "cubic-bezier(0.390, 0.575, 0.565, 1.000)",
  "ease-out-expo": "cubic-bezier(0.190, 1.000, 0.220, 1.000)",
  "ease-out-circ": "cubic-bezier(0.075, 0.820, 0.165, 1.000)",
  "ease-out-back": "cubic-bezier(0.175, 0.885, 0.320, 1.275)",
  "ease-in-out-quad": "cubic-bezier(0.455, 0.030, 0.515, 0.955)",
  "ease-in-out-cubic": "cubic-bezier(0.645, 0.045, 0.355, 1.000)",
  "ease-in-out-quart": "cubic-bezier(0.770, 0.000, 0.175, 1.000)",
  "ease-in-out-quint": "cubic-bezier(0.860, 0.000, 0.070, 1.000)",
  "ease-in-out-sine": "cubic-bezier(0.445, 0.050, 0.550, 0.950)",
  "ease-in-out-expo": "cubic-bezier(1.000, 0.000, 0.000, 1.000)",
  "ease-in-out-circ": "cubic-bezier(0.785, 0.135, 0.150, 0.860)",
  "ease-in-out-back": "cubic-bezier(0.680, -0.550, 0.265, 1.550)"
};

export class Animate extends React.Component<Props, State> {
  // Set default properties
  static defaultProps = {
    delay: 500,
    duration: 300,
    target: "top",
    trigger: "mount"
  };

  // Items shown in property panel
  static propertyControls: PropertyControls = {
    trigger: {
      type: ControlType.Enum,
      options: ["mount", "tap"],
      optionTitles: ["On Mount", "On Tap"],
      title: "Trigger"
    },

    target: {
      type: ControlType.Enum,
      options: [
        "top",
        "left",
        "right",
        "bottom",
        "opacity",
        "rotate",
        "scale",
        "scaleX",
        "scaleY"
      ],
      optionTitles: [
        "Top",
        "Left",
        "Right",
        "Bottom",
        "Opacity",
        "Rotate",
        "Scale",
        "Scale X",
        "Scale Y"
      ],
      title: "Animate"
    },
    rotateStart: {
      type: ControlType.Number,
      defaultValue: 0,
      title: "Start (deg)",
      min: -360,
      max: 360,
      hidden: (props: Props) => {
        return props.target !== "rotate";
      }
    },
    rotateEnd: {
      type: ControlType.Number,
      defaultValue: 0,
      title: "End (deg)",
      min: -360,
      max: 360,
      hidden: (props: Props) => {
        return props.target !== "rotate";
      }
    },
    easing: {
      type: ControlType.Enum,
      options: [
        "linear",
        "ease",
        "ease-in",
        "ease-out",
        "ease-in-out",
        "ease-in-quad",
        "ease-in-cubic",
        "ease-in-quart",
        "ease-in-quint",
        "ease-in-sine",
        "ease-in-expo",
        "ease-in-circ",
        "ease-in-back",
        "ease-out-quad",
        "ease-out-cubic",
        "ease-out-quart",
        "ease-out-quint",
        "ease-out-sine",
        "ease-out-expo",
        "ease-out-circ",
        "ease-out-back",
        "ease-in-out-quad",
        "ease-in-out-cubic",
        "ease-in-out-quart",
        "ease-in-out-quint",
        "ease-in-out-sine",
        "ease-in-out-expo",
        "ease-in-out-circ",
        "ease-in-out-back"
      ],
      title: "Easing"
    },
    delay: { type: ControlType.Number, title: "Delay", min: 0, max: 5000 },
    duration: {
      type: ControlType.Number,
      title: "Duration",
      min: 0,
      max: 5000
    },
    transformOrigin: {
      type: ControlType.Boolean,
      title: "Origin"
    },
    transformOriginXType: {
      type: ControlType.SegmentedEnum,
      options: ["%", "px"],
      optionTitles: ["%", "px"],
      defaultValue: "px",
      title: "Origin X",
      hidden: (props: Props) => {
        return !props.transformOrigin;
      }
    },
    transformOriginXPercent: {
      type: ControlType.Number,
      min: -100,
      max: 200,
      defaultValue: 50,
      title: "Origin X (%)",
      hidden: (props: Props) => {
        return !props.transformOrigin || !(props.transformOriginXType === "%");
      }
    },
    transformOriginXPixels: {
      type: ControlType.Number,
      min: -5000,
      max: 10000,
      defaultValue: 0,
      title: "Origin X (px)",
      hidden: (props: Props) => {
        return !props.transformOrigin || !(props.transformOriginXType === "px");
      }
    },
    transformOriginYType: {
      type: ControlType.SegmentedEnum,
      options: ["%", "px"],
      optionTitles: ["%", "px"],
      defaultValue: "px",
      title: "Origin Y",
      hidden: (props: Props) => {
        return !props.transformOrigin;
      }
    },
    transformOriginYPercent: {
      type: ControlType.Number,
      min: -100,
      max: 200,
      defaultValue: 50,
      title: "Origin Y (%)",
      hidden: (props: Props) => {
        return !props.transformOrigin || !(props.transformOriginYType === "%");
      }
    },
    transformOriginYPixels: {
      type: ControlType.Number,
      min: -5000,
      max: 10000,
      defaultValue: 0,
      title: "Origin Y (px)",
      hidden: (props: Props) => {
        return !props.transformOrigin || !(props.transformOriginYType === "px");
      }
    }
  };
  myRef: React.RefObject<HTMLDivElement>;

  constructor(props) {
    super(props);
    this.myRef = React.createRef();
    this.state = {
      finished: false
    };
  }

  componentDidMount() {
    if (this.myRef && this.props.trigger === "mount") {
      window.requestAnimationFrame(() => this.setState({ finished: true }));
    }
  }

  onTap() {
    if (this.myRef && this.props.trigger === "tap") {
      window.requestAnimationFrame(() => this.setState({ finished: true }));
    }
  }

  render() {
    const timingFunction = cubicMap[this.props.easing] || this.props.easing;
    // We sure that child is always there
    const { width = 100, height = 100 } =
      this.props.children && React.Children.count(this.props.children)
        ? React.Children.map(this.props.children, child => {
            if (typeof child === "string" || typeof child === "number")
              return {};
            return { width: child.props.width, height: child.props.height };
          })[0]
        : {};

    const wrapperStyle: React.CSSProperties = {
      width,
      height,
      transitionDelay: `${this.props.delay}ms`,
      transformOrigin: this.props.transformOrigin
        ? `${
            this.props.transformOriginXType === "px"
              ? `${this.props.transformOriginXPixels}px`
              : `${this.props.transformOriginXPercent}%`
          } ${
            this.props.transformOriginYType === "px"
              ? `${this.props.transformOriginYPixels}px`
              : `${this.props.transformOriginYPercent}%`
          }`
        : "center",
      transitionDuration: `${this.props.duration}ms`,
      transitionProperty:
        this.props.target === "opacity" ? "opacity" : "transform",
      transitionTimingFunction: timingFunction,
      display: "flex",
      position: "relative",
      justifyContent: "center",
      alignItems: "center"
    };

    if (!this.state.finished) {
      if (this.props.target === "rotate") {
        wrapperStyle.transform = `rotate(${this.props.rotateStart}deg)`;
      }
      if (this.props.target === "top") {
        wrapperStyle.transform = `translateY(${-this.props.height}px)`;
      }
      if (this.props.target === "left") {
        wrapperStyle.transform = `translateX(${-this.props.width}px)`;
      }
      if (this.props.target === "bottom") {
        wrapperStyle.transform = `translateY(${this.props.height}px)`;
      }
      if (this.props.target === "right") {
        wrapperStyle.transform = `translateX(${this.props.width}px)`;
      }
      if (this.props.target === "opacity") {
        wrapperStyle.opacity = 0;
      }
      if (this.props.target === "scale") {
        wrapperStyle.transform = `scale(0)`;
      }
      if (this.props.target === "scaleX") {
        wrapperStyle.transform = `scaleX(0)`;
      }
      if (this.props.target === "scaleY") {
        wrapperStyle.transform = `scaleY(0)`;
      }
    } else {
      if (this.props.target === "rotate") {
        wrapperStyle.transform = `rotate(${this.props.rotateEnd}deg)`;
      }
      if (this.props.target === "top") {
        wrapperStyle.transform = `translateY(0)`;
      }
      if (this.props.target === "left") {
        wrapperStyle.transform = `translateX(0)`;
      }
      if (this.props.target === "bottom") {
        wrapperStyle.transform = `translateY(0)`;
      }
      if (this.props.target === "right") {
        wrapperStyle.transform = `translateX(0)`;
      }
      if (this.props.target === "opacity") {
        wrapperStyle.opacity = 1;
      }
      if (this.props.target === "scale") {
        wrapperStyle.transform = "scale(1)";
      }
      if (this.props.target === "scaleX") {
        wrapperStyle.transform = `scaleX(1)`;
      }
      if (this.props.target === "scaleY") {
        wrapperStyle.transform = `scaleY(1)`;
      }
    }
    return (
      <div style={style} onClick={() => this.onTap()}>
        <div ref={this.myRef} style={wrapperStyle}>
          {this.props.children}
        </div>
      </div>
    );
  }
}
