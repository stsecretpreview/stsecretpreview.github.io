/// <reference types="react" />
import { ContentState } from 'draft-js';
import { EditorState } from 'draft-js';
import { List } from 'immutable';
import { ListenerFn } from 'eventemitter3';
import { RawDraftContentState } from 'draft-js';
import * as React from 'react';
import { Record } from 'immutable';

/**
 * @public
 */
export declare function Animatable<Value>(value: Value | Animatable<Value>): Animatable<Value>;

/**
 * @public
 */
export declare interface Animatable<Value> extends UpdateObserver<Value> {
    get(): Value;
    /* Excluded from this release type: set */
    /* Excluded from this release type: set */
    /* Excluded from this release type: finishTransaction */
}

/**
 * @public
 */
export declare namespace Animatable {
    /* Excluded from this release type: transaction */
    /**
     * @public
     */
    export function getNumber(value: number | Animatable<number> | null | undefined, defaultValue?: number): number;
    /**
     * @public
     */
    export function get<Value>(value: Value | Animatable<Value> | null | undefined, defaultValue: Value): Value;
    /* Excluded from this release type: objectToValues */
}

export declare type AnimatableObject<T> = {
    [K in keyof T]: ToAnimatableOrValue<T[K]>;
};

/**
 * Animate a value or object.
 *
 * @remarks
 * Recommended use is to use convenience functions from the `animate` namespace
 * instead of passing an animator. Only use this for low-level animation tweaking.
 *
 * @param from - The animatable value or object to start from
 * @param to - The value to animate to
 * @param animator - Animator to use.
 * @param options - Animation options
 * @public
 */
export declare function animate<Value, Options>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, animator?: AnimatorClass<Value, Options>, options?: Partial<Options & AnimationOptions<Value>>): FramerAnimation<Value, Options>;

/**
 * @public
 */
export declare namespace animate {
    export function spring<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<SpringOptions & AnimationOptions<Value>>): FramerAnimation<Value, SpringOptions>;
    export function bezier<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<BezierOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
    export function linear<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<EaseOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
    export function ease<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<EaseOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
    export function easeIn<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<EaseOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
    export function easeOut<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<EaseOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
    export function easeInOut<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<EaseOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
}

/* Excluded from this release type: AnimationDriver */

/**
 * @public
 */
declare interface AnimationInterface {
    /* Excluded from this release type: play */
    cancel(): void;
    /* Excluded from this release type: finish */
    isFinished(): boolean;
}

declare interface AnimationOptions<Value> extends InterpolationOptions {
    /* Excluded from this release type: customInterpolation */
    /* Excluded from this release type: precalculate */
}

/* Excluded from this release type: Animator */

/**
 * @public
 */
declare interface AnimatorClass<Value, Options = any> {
    /* Excluded from this release type: __new */
}

declare const AnyInterpolation: ValueInterpolation;

declare interface ArrayControlDescription<P = any, Q = any> extends BaseControlDescription<P> {
    type: ControlType.Array;
    propertyControl: FlatControlDescription<Q>;
    maxCount?: number;
    defaultValue?: any[];
}

/* Excluded from this release type: Axis */

declare type Background = Color | Gradient | BackgroundImage | string;

declare interface BackgroundFilterProperties {
    backgroundBlur: number;
}

declare interface BackgroundImage {
    src: string;
    pixelWidth?: number;
    pixelHeight?: number;
    intrinsicWidth?: number;
    intrinsicHeight?: number;
    fit?: ImageFit;
}

declare namespace BackgroundImage {
    const isImageObject: (image: any) => image is object & BackgroundImage;
}

declare interface BackgroundProperties {
    background: Animatable<Background> | Background | null;
}

declare interface BaseControlDescription<P = any> {
    title?: string;
    hidden?: (props: P) => boolean;
}

declare enum Bezier {
    Linear = "linear",
    Ease = "ease",
    EaseIn = "ease-in",
    EaseOut = "ease-out",
    EaseInOut = "ease-in-out"
}

/* Excluded from this release type: BezierAnimator */

declare interface BezierOptions {
    curve: Curve;
    duration: number;
}

declare type BlendingMode = "normal" | "multiply" | "screen" | "overlay" | "darken" | "lighten" | "color-dodge" | "color-burn" | "hard-light" | "soft-light" | "difference" | "exclusion" | "hue" | "saturation" | "color" | "luminosity";

declare interface BlendingProperties {
    blendingMode: BlendingMode;
}

declare interface BooleanControlDescription<P = any> extends BaseControlDescription<P> {
    type: ControlType.Boolean;
    defaultValue?: boolean;
    disabledTitle?: string;
    enabledTitle?: string;
}

declare type BorderStyle = "solid" | "dashed" | "dotted" | "double";

declare interface BoxShadow {
    inset: boolean;
    color: string;
    x: number;
    y: number;
    blur: number;
    spread: number;
}

declare namespace BoxShadow {
    function is(shadow: any): shadow is BoxShadow;
    function toCSS(shadow: BoxShadow): string;
}

declare interface BoxShadowProperties {
    shadows: BoxShadow[];
}

export declare type Cancel = () => void;

/* Excluded from this release type: CanvasStore */

declare interface Change<Value> {
    value: Value;
    oldValue?: Value;
}

/**
 * @public
 */
export declare function Color(color: IncomingColor | Color | number, r?: number, g?: number, b?: number): Color;

/**
 * @public
 */
export declare interface Color {
    r: number;
    g: number;
    b: number;
    h: number;
    s: number;
    l: number;
    a: number;
    roundA: number;
    format: ColorFormat;
    initialValue?: string;
    isValid?: boolean;
}

/**
 * @beta
 */
export declare namespace Color {
    const inspect: (color: Color, initialValue?: string | undefined) => string;
    const isColorObject: (color: any) => color is object & Color;
    const toString: (color: Color) => string;
    const toHex: (color: Color, allow3Char?: boolean) => string;
    const toHexString: (color: Color, allow3Char?: boolean) => string;
    const toRgbString: (color: Color) => string;
    const toHusl: (color: Color) => ColorHSLA;
    const toHslString: (color: Color) => string;
    const toHsv: (color: Color) => ColorHSVA;
    const toHsvString: (color: Color) => string;
    const toName: (color: Color) => string | false;
    const toHsl: (color: Color) => ColorHSLA;
    const toRgb: (color: Color) => ColorRGBA;
    const brighten: (color: Color, amount?: number) => Color;
    const lighten: (color: Color, amount?: number) => Color;
    const darken: (color: Color, amount?: number) => Color;
    const desaturate: (color: Color, amount?: number) => Color;
    const grayscale: (color: Color) => Color;
    const saturate: (color: Color, amount?: number) => Color;
    const hueRotate: (color: Color, angle: number) => Color;
    const alpha: (color: Color, a?: number) => Color;
    const transparent: (color: Color) => Color;
    const multiplyAlpha: (color: Color, a?: number) => Color;
    const interpolate: (colorA: Color, colorB: Color, model?: ColorMixModelType) => (progress: number) => Color;
    const isColorString: (colorString: string | object) => boolean;
    const mix: (colorA: Color, colorB: Color, fraction?: number, limit?: boolean, model?: ColorMixModelType) => Color | null;
    const random: (a?: number) => Color;
    const grey: (g?: number, a?: number) => Color;
    const gray: (g?: number, a?: number) => Color;
    const isColor: (color: string | Color) => boolean;
    const rgbToHsl: (r: number, g: number, b: number) => ColorHSL;
    const isValidColorProperty: (name: string, value: string) => boolean;
    const difference: (colorA: Color, colorB: Color) => number;
    const equal: (colorA: Color, colorB: Color, tolerance?: number) => boolean;
}

declare interface ColorControlDescription<P = any> extends BaseControlDescription<P> {
    type: ControlType.Color;
    defaultValue?: string;
}

declare enum ColorFormat {
    RGB = "rgb",
    HSL = "hsl",
    HSV = "hsv",
    HEX = "hex",
    NAME = "name"
}

declare interface ColorHSL {
    h: number;
    s: number;
    l: number;
}

declare type ColorHSLA = ColorHSL & {
    a: number;
};

declare interface ColorHSV {
    h: number;
    s: number;
    v: number;
}

declare type ColorHSVA = ColorHSV & {
    a: number;
};

declare enum ColorMixModelType {
    RGB = "rgb",
    RGBA = "rgba",
    HSL = "hsl",
    HSLA = "hsla",
    HUSL = "husl"
}

declare interface ColorRGB {
    r: number;
    g: number;
    b: number;
}

declare type ColorRGBA = ColorRGB & {
    a: number;
};

declare type CompactControlsDescription<P = any> = NumberControlDescription<P> | EnumControlDescription<P>;

/* Excluded from this release type: ComponentContainer */

/* Excluded from this release type: ComponentContainerProperties */

/* Excluded from this release type: ComponentContainerProps */

/* Excluded from this release type: ComponentContainerState */

/* Excluded from this release type: ComponentDefinition */

/* Excluded from this release type: ComponentIdentifier */

declare interface ComponentInstanceDescription<P = any> extends BaseControlDescription<P> {
    type: ControlType.ComponentInstance;
}

declare const componentLoader: ComponentLoader;

/**
 * @ internal
 */
declare interface ComponentLoader {
    /* Excluded from this release type: packageDisplayName */
    /* Excluded from this release type: localPackageIdentifier */
    /* Excluded from this release type: packageIdentifiers */
    /* Excluded from this release type: componentsForPackage */
    /* Excluded from this release type: componentForIdentifier */
    /* Excluded from this release type: errorForIdentifier */
    /* Excluded from this release type: componentIdentifiers */
    /* Excluded from this release type: forEachDesignComponents */
    /* Excluded from this release type: forEachComponent */
}

/* Excluded from this release type: ComponentType */

declare type ConstraintAuto = "auto";

declare type ConstraintDimension = Animatable<number> | number | ConstraintPercentage | ConstraintAuto | ConstraintFreespaceFraction;

declare type ConstraintFreespaceFraction = string;

declare type ConstraintPercentage = string;

declare interface ConstraintProperties extends Partial<WithFractionOfFreeSpace> {
    parentSize: Size | AnimatableObject<Size> | null;
    left: Animatable<number> | number | null;
    right: Animatable<number> | number | null;
    top: Animatable<number> | number | null;
    bottom: Animatable<number> | number | null;
    centerX: ConstraintPercentage;
    centerY: ConstraintPercentage;
    width: ConstraintDimension;
    height: ConstraintDimension;
    aspectRatio: number | null;
    autoSize?: boolean;
}

declare interface ConstraintValuesBase {
    left: number | null;
    right: number | null;
    top: number | null;
    bottom: number | null;
    centerAnchorX: number;
    centerAnchorY: number;
    widthType: DimensionType;
    heightType: DimensionType;
    aspectRatio: number | null;
}

declare type ControlDescription<P = any, Q = any> = FlatControlDescription<P> | ArrayControlDescription<P, Q> | ObjectControlDescription<P, Q>;

declare type ControlPoints = [number, number, number, number];

/**
 * @public
 */
export declare const enum ControlType {
    Boolean = "boolean",
    Number = "number",
    String = "string",
    FusedNumber = "fusednumber",
    Enum = "enum",
    SegmentedEnum = "segmentedenum",
    Color = "color",
    Image = "image",
    File = "file",
    ComponentInstance = "componentinstance",
    Array = "array",
    Object = "object"
}

/* Excluded from this release type: ConvertColor */

/* Excluded from this release type: createDesignComponent */

declare type Curve = ControlPoints | Bezier;

declare interface DampingDurationSpringOptions {
    dampingRatio: number;
    duration: number;
    velocity: number;
    mass: number;
}

/**
 * @public
 */
export declare function Data<T extends object = object>(initial?: Partial<T> | object): T;

/**
 * @internal
 */
export declare namespace Data {
    let _stores: object[];
    export function addData(data: object): void;
    export function addObserver<T extends object>(target: T, observer: Observer<T>): Cancel;
}

/* Excluded from this release type: DataObserver */

/* Excluded from this release type: DesignComponentDefinition */

/**
 * @public
 */
export declare class Device extends React.Component<Partial<DeviceProperties>> {
    /* Excluded from this release type: defaultProps */
    /* Excluded from this release type: registry */
    /* Excluded from this release type: descriptor */
    /* Excluded from this release type: descriptor */
    /* Excluded from this release type: skins */
    /* Excluded from this release type: hands */
    /* Excluded from this release type: svgScreenMask */
    /* Excluded from this release type: properties */
    /* Excluded from this release type: componentDidMount */
    /* Excluded from this release type: componentDidUpdate */
    /* Excluded from this release type: computeRequiredPackages */
    /* Excluded from this release type: render */
    private getSkin;
    private getHand;
    private outerStyle;
    private static skinOrHandFromPackage;
    private toLocalPath;
}

/* Excluded from this release type: DeviceDescriptor */

/* Excluded from this release type: DeviceHand */

/* Excluded from this release type: DeviceHands */

/**
 * @public
 */
export declare interface DeviceProperties {
    parentSize: null | AnimatableObject<Size>;
    deviceSize: Size;
    contentSize: Size;
    skin?: string;
    hand?: string;
    zoom: number;
    responsive: boolean;
    rotate?: boolean;
    background?: string;
    onRequirePackage: (pakkage: string, displayName: string) => void;
    /* Excluded from this release type: renderer */
}

/* Excluded from this release type: DeviceRegistry */

/* Excluded from this release type: DevicesData */

/* Excluded from this release type: DeviceSkin */

/* Excluded from this release type: DeviceSkins */

declare enum DimensionType {
    FixedNumber = 0,
    Percentage = 1,
    Auto = 2,
    FractionOfFreeSpace = 3
}

declare type DragEventHandler<Draggable> = (event: FramerEvent, draggable: Draggable) => void;

declare interface DragEvents<Draggable> {
    onMove: (point: Point, draggable: Draggable) => void;
    /* Excluded from this release type: onDragDirectionLockStart */
    onDragAnimationStart: (animation: {
        x: AnimationInterface;
        y: AnimationInterface;
    }, draggable: Draggable) => void;
    onDragAnimationEnd: (animation: {
        x: AnimationInterface;
        y: AnimationInterface;
    }, draggable: Draggable) => void;
    onDragSessionStart: DragEventHandler<Draggable>;
    onDragSessionMove: DragEventHandler<Draggable>;
    onDragSessionEnd: DragEventHandler<Draggable>;
    onDragStart: DragEventHandler<Draggable>;
    onDragWillMove: DragEventHandler<Draggable>;
    onDragDidMove: DragEventHandler<Draggable>;
    onDragEnd: DragEventHandler<Draggable>;
}

declare const Draggable: React.ComponentClass<Partial<FrameProperties_2> & Partial<DraggableProps<typeof Frame>>>;

declare type DraggableFrameSpecificProps = Partial<FrameProperties_2> & Partial<DraggableSpecificProps<DraggableType>>;

declare interface DraggableProps<Draggable> extends DraggableSpecificProps<Draggable> {
    enabled: boolean;
}

declare interface DraggableSpecificProps<Draggable> extends Partial<DragEvents<Draggable>> {
    momentum: boolean;
    momentumOptions: {
        friction: number;
        tolerance: number;
    };
    momentumVelocityMultiplier: number;
    speedX: number;
    speedY: number;
    bounce: boolean;
    bounceOptions: {
        friction: number;
        tension: number;
        tolerance: number;
    };
    directionLock: boolean;
    directionLockThreshold: {
        x: number;
        y: number;
    };
    overdrag: boolean;
    overdragScale: number;
    pixelAlign: boolean;
    velocityTimeout: number;
    velocityScale: number;
    horizontal: boolean;
    vertical: boolean;
    constraints: Partial<Rect>;
    mouseWheel: boolean;
}

declare type DraggableType = typeof Frame;

/* Excluded from this release type: DriverClass */

declare type EaseOptions = Omit<BezierOptions, "curve">;

declare interface EnumControlDescription<P = any> extends BaseControlDescription<P> {
    type: ControlType.Enum;
    defaultValue?: string;
    options: string[];
    optionTitles?: string[] | ((props: P | null) => string[]);
}

/* Excluded from this release type: ErrorDefinition */

declare type EventDispatcher = ((type: string, event: FramerEvent, target: EventTarget) => void);

declare class EventEmitter<EventName> {
    private _emitter;
    eventNames(): string[];
    eventListeners(): {
        [index: string]: ListenerFn[];
    };
    on(eventName: EventName, fn: Function): void;
    off(eventName: EventName, fn: Function): void;
    once(eventName: EventName, fn: Function): void;
    unique(eventName: EventName, fn: Function): void;
    addEventListener(eventName: EventName, fn: Function, once: boolean, unique: boolean, context: Object): void;
    removeEventListeners(eventName?: EventName, fn?: Function): void;
    removeAllEventListeners(): void;
    countEventListeners(eventName?: EventName, handler?: Function): number;
    emit(eventName: EventName, ...args: any[]): void;
}

declare type EventHandler = (event: FramerEvent) => void;

/* Excluded from this release type: ExternalDeviceHand */

/* Excluded from this release type: ExternalDeviceSkin */

declare interface FileControlDescription<P = any> extends BaseControlDescription<P> {
    type: ControlType.File;
    allowedFileTypes: string[];
}

declare interface FillProperties {
    fill: Animatable<Background> | Background | null;
}

declare interface FilterNumberProperties {
    brightness: number;
    contrast: number;
    grayscale: number;
    hueRotate: number;
    invert: number;
    saturate: number;
    sepia: number;
    blur: number;
}

declare interface FilterProperties extends FilterNumberProperties {
    dropShadows: Shadow[];
}

/**
 * @public
 */
declare type FinishFunction = (transaction: TransactionId) => void;

declare type FlatControlDescription<P = any> = CompactControlsDescription<P> | BooleanControlDescription<P> | StringControlDescription<P> | ColorControlDescription<P> | FusedNumberControlDescription<P> | SegmentedEnumControlDescription<P> | ImageControlDescription<P> | FileControlDescription<P> | ComponentInstanceDescription<P>;

declare const Frame: React.ComponentClass<Partial<FrameProperties>>;

export declare type Frame = React.Component<FrameProperties>;

export declare type FrameProperties = FrameProperties_2 & WithEventsProperties;

declare interface FrameProperties_2 extends FrameSpecificProps, LayerProps {
}

/**
 * This could be called just Animation, but it's type would clash with
 * javascript's native Animation: https://developer.mozilla.org/en-US/docs/Web/API/Animation
 * So if you forget the import, you would get weird errors.
 *
 * Also, this class follows the native Animation as much as possible.
 * @public
 */
export declare class FramerAnimation<Value, AnimatorOptions> {
    /* Excluded from this release type: driver */
    /* Excluded from this release type: __constructor */
    /* Excluded from this release type: driverCallbackHandler */
    /* Excluded from this release type: playStateSource */
    /* Excluded from this release type: playStateValue */
    /* Excluded from this release type: playState */
    /* Excluded from this release type: onfinish */
    /* Excluded from this release type: oncancel */
    /* Excluded from this release type: readyPromise */
    /* Excluded from this release type: readyResolve */
    /* Excluded from this release type: resetReadyPromise */
    /* Excluded from this release type: ready */
    /* Excluded from this release type: finishedPromise */
    /* Excluded from this release type: finishedResolve */
    /* Excluded from this release type: finishedReject */
    /* Excluded from this release type: resetFinishedPromise */
    /* Excluded from this release type: finished */
    /* Excluded from this release type: play */
    /* Excluded from this release type: cancel */
    /* Excluded from this release type: finish */
    /* Excluded from this release type: isFinished */
}

declare type FramerAnimationState = "idle" | "running" | "finished";

declare const FramerAppleIMac: typeof Device;

declare const FramerAppleIPadAir: typeof Device;

declare const FramerAppleIPadMini: typeof Device;

declare const FramerAppleIPadPro: typeof Device;

declare const FramerAppleIPhone8: typeof Device;

declare const FramerAppleIPhone8Plus: typeof Device;

declare const FramerAppleIPhoneSE: typeof Device;

declare const FramerAppleIPhoneX: typeof Device;

declare const FramerAppleIPhoneXR: typeof Device;

declare const FramerAppleIPhoneXS: typeof Device;

declare const FramerAppleIPhoneXSMax: typeof Device;

declare const FramerAppleMacBook: typeof Device;

declare const FramerAppleMacBookAir: typeof Device;

declare const FramerAppleMacBookPro: typeof Device;

declare const FramerAppleThunderboltDisplay: typeof Device;

declare const FramerAppleWatch38: typeof Device;

declare const FramerAppleWatch42: typeof Device;

declare const FramerDellXPS: typeof Device;

/**
 * @public
 */
export declare class FramerEvent {
    /* Excluded from this release type: originalEvent */
    /* Excluded from this release type: session */
    /* Excluded from this release type: time */
    /* Excluded from this release type: loopTime */
    /* Excluded from this release type: point */
    /* Excluded from this release type: devicePoint */
    /* Excluded from this release type: target */
    /* Excluded from this release type: delta */
    /* Excluded from this release type: __constructor */
    private static eventLikeFromOriginalEvent;
    /* Excluded from this release type: velocity */
    /* Excluded from this release type: offset */
    /* Excluded from this release type: isLeftMouseClick */
}

declare const FramerEventListener: React.ComponentType<any>;

/* Excluded from this release type: FramerEventSession */

declare const FramerGoogleNexus4: typeof Device;

declare const FramerGoogleNexus5X: typeof Device;

declare const FramerGoogleNexus6: typeof Device;

declare const FramerGoogleNexusTablet: typeof Device;

declare const FramerGooglePixel2: typeof Device;

declare const FramerGooglePixel2XL: typeof Device;

declare const FramerGooglePixel3: typeof Device;

declare const FramerGooglePixel3XL: typeof Device;

declare const FramerHTCOneA9: typeof Device;

declare const FramerMicrosoftLumia950: typeof Device;

declare const FramerMicrosoftSurfaceBook: typeof Device;

declare const FramerMicrosoftSurfacePro3: typeof Device;

declare const FramerMicrosoftSurfacePro4: typeof Device;

declare const FramerSamsungGalaxyS8: typeof Device;

declare const FramerSamsungGalaxyS9: typeof Device;

declare const FramerSamsungNote5: typeof Device;

declare const FramerSonySmartWatch: typeof Device;

declare const FramerSonyW850C: typeof Device;

declare interface FrameSpecificProps extends ConstraintProperties, TransformProperties, VisualProperties {
    visible: boolean;
    name?: string;
    backfaceVisible?: boolean | Animatable<boolean>;
    perspective?: number | Animatable<number>;
    preserve3d?: boolean | Animatable<boolean>;
    borderWidth: number | Partial<{
        top: number;
        bottom: number;
        left: number;
        right: number;
    }>;
    borderColor: string;
    borderStyle: BorderStyle;
    style?: React.CSSProperties;
    className?: string;
    _overrideForwardingDescription?: {
        [key: string]: string;
    };
}

declare interface FusedNumberControlDescription<P = any> extends BaseControlDescription<P> {
    type: ControlType.FusedNumber;
    defaultValue?: number;
    toggleKey: keyof P;
    toggleTitles: [string, string];
    valueKeys: [keyof P, keyof P, keyof P, keyof P];
    valueLabels: [string, string, string, string];
    min?: number;
}

/* Excluded from this release type: GestureHandler */

/* Excluded from this release type: getURLs */

/**
 * @public
 */
declare type Gradient = LinearGradient | RadialGradient;

declare interface IdentityProps extends React.Props<any> {
    id?: string;
}

declare interface ImageControlDescription<P = any> extends BaseControlDescription<P> {
    type: ControlType.Image;
}

declare type ImageFit = "fill" | "fit" | "stretch";

declare type IncomingColor = ColorRGB | ColorHSL | ColorRGBA | ColorHSLA | string;

/**
 * @public
 */
declare interface Interpolation<Value = any> {
    /* Excluded from this release type: interpolate */
    /* Excluded from this release type: difference */
}

/**
 * @beta
 */
declare namespace Interpolation {
    function handleUndefined<Value>(from: Value, to: Value): [Value, Value];
}

declare interface InterpolationOptions {
    colorModel: ColorMixModelType;
}

/* Excluded from this release type: Interpolator */

/* Excluded from this release type: isOverride */

/* Excluded from this release type: isReactDefinition */

/* Excluded from this release type: JSONArray */

/* Excluded from this release type: JSONData */

/* Excluded from this release type: JSONObject */

/* Excluded from this release type: Layer */

declare interface LayerProps extends IdentityProps {
    willChangeTransform: boolean;
    _forwardedOverrides?: {
        [key: string]: any;
    };
}

/* Excluded from this release type: Line */

/**
 * @public
 */
declare interface LinearGradient {
    alpha: number;
    angle: number;
    start: string;
    end: string;
}

/**
 * @alpha
 */
declare namespace LinearGradient {
    function isLinearGradient(linearGradient: any): linearGradient is LinearGradient;
    function hash(linearGradient: LinearGradient): number;
    function toCSS(linearGradient: LinearGradient, overrideAngle?: number): string;
}

/* Excluded from this release type: LineCap */

/* Excluded from this release type: LineJoin */

/* Excluded from this release type: loadJSON */

/**
 * @public
 */
declare class Loop extends EventEmitter<LoopEventNames> {
    private _started;
    private _frame;
    private _frameTasks;
    /* Excluded from this release type: addFrameTask */
    private _processFrameTasks;
    /* Excluded from this release type: TimeStep */
    /* Excluded from this release type: __constructor */
    /* Excluded from this release type: start */
    /* Excluded from this release type: stop */
    /* Excluded from this release type: frame */
    /* Excluded from this release type: time */
    /* Excluded from this release type: tick */
}

declare type LoopEventNames = "render" | "update" | "finish";

declare const MainLoop: Loop;

/* Excluded from this release type: NavigateTo */

/* Excluded from this release type: Navigation */

/* Excluded from this release type: NavigationItem */

/* Excluded from this release type: NavigationLink */

/* Excluded from this release type: NavigationProps */

/* Excluded from this release type: NavigationState */

/* Excluded from this release type: NavigationTarget */

/* Excluded from this release type: NavigationTransition */

/* Excluded from this release type: NavigationTransitionDirection */

/* Excluded from this release type: NavigationTransitionOptions */

/* Excluded from this release type: Navigator */

declare interface NumberControlDescription<P = any> extends BaseControlDescription<P> {
    type: ControlType.Number;
    defaultValue?: number;
    max?: number;
    min?: number;
    unit?: string;
    step?: number;
    displayStepper?: boolean;
}

declare interface ObjectControlDescription<P = any, Q = any> extends BaseControlDescription<P> {
    type: ControlType.Object;
    propertyControls: {
        [K in keyof Q]?: CompactControlsDescription<Partial<Q>>;
    };
}

/* Excluded from this release type: ObservableObject */

/**
 * @public
 */
declare type Observer<Value> = {
    update: UpdateFunction<Value>;
    finish: FinishFunction;
} | UpdateFunction<Value>;

declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

declare type Overflow = "visible" | "hidden" | "scroll" | "auto";

declare interface OverflowProperties {
    overflow: Overflow;
}

export declare type Override<T extends object = FrameProperties & {
    [key: string]: any;
}> = OverrideObject<T> | OverrideFunction<T>;

export declare type OverrideFunction<P extends object = any> = (props: P) => Partial<P>;

export declare type OverrideObject<T extends object = any> = Partial<T>;

/* Excluded from this release type: PackageIdentifier */

/**
 * @public
 */
export declare class Page extends React.Component<Partial<PageProperties>> {
    static _stylableContainer: boolean;
    private pages;
    private animation;
    private propsBoundedCurrentPage;
    private shouldReflectPropsBoundedCurrentPage;
    private contentOffset;
    private currentContentPage;
    private cancelUpdating;
    private static pageProps;
    static defaultProps: PageProperties;
    static propertyControls: PropertyControls<PageProperties>;
    private readonly properties;
    private readonly isHorizontalDirection;
    private readonly currentContentOffset;
    private boundedCurrentPage;
    /* Excluded from this release type: componentWillUpdate */
    /* Excluded from this release type: componentDidUpdate */
    private nearestPageIndex;
    private onDragAnimationStart;
    private onDragSessionStart;
    private applyEffects;
    private contentOffsetUpdated;
    private cancelAnimation;
    private effectValues;
    private wrapHandler;
    private offsetForPage;
    /* Excluded from this release type: render */
}

declare enum PageAlignment {
    Start = "start",
    Center = "center",
    End = "end"
}

declare enum PageContentDimension {
    Auto = "auto",
    Stretch = "stretch"
}

declare type PageDirection = "horizontal" | "vertical";

/**
 * @public
 */
export declare enum PageEffectDefault {
    None = "none",
    Cube = "cube",
    CoverFlow = "coverflow",
    Wheel = "wheel",
    Pile = "pile"
}

declare type PageEffectFunction = (info: PageEffectInfo) => Partial<FrameProperties_2>;

declare interface PageEffectInfo {
    offset: number;
    normalizedOffset: number;
    size: Size;
    index: number;
    direction: PageDirection;
    gap: number;
    pageCount: number;
}

declare interface PageEvents {
    onChangePage: (currentIndex: number, previousIndex: number, pageComponent: Page) => void;
}

declare interface PageProperties extends PageSpecificProps, FrameSpecificProps, LayerProps, Partial<PageEvents>, Partial<DragEvents<typeof Frame>>, Partial<ScrollEvents> {
}

declare interface PageSpecificProps {
    direction: PageDirection;
    contentWidth: PageContentDimension | number;
    contentHeight: PageContentDimension | number;
    alignment: PageAlignment;
    currentPage: number;
    animateCurrentPageUpdate: boolean;
    gap: number;
    padding: number;
    paddingPerSide: boolean;
    paddingTop: number;
    paddingRight: number;
    paddingBottom: number;
    paddingLeft: number;
    momentum: boolean;
    draggingEnabled: boolean;
    defaultEffect: PageEffectDefault;
    effect?: PageEffectFunction;
}

/* Excluded from this release type: PathSegment */

declare const PathSegmentRecord: Record.Class;

/**
 * @public
 */
export declare function Point(x: number, y: number): Point;

/**
 * @public
 */
export declare interface Point {
    x: number;
    y: number;
}

/**
 * @beta
 */
export declare namespace Point {
    const add: (...args: Point[]) => Point;
    const subtract: (a: Point, b: Point) => Point;
    const multiply: (a: Point, b: number) => Point;
    const divide: (a: Point, b: number) => Point;
    const absolute: (point: Point) => Point;
    const reverse: (point: Point) => Point;
    const pixelAligned: (point: Point, offset?: Point) => Point;
    const distance: (a: Point, b: Point) => number;
    const angle: (a: Point, b: Point) => number;
    const isEqual: (a: Point, b: Point) => boolean;
    const rotationNormalizer: () => (value: number) => number;
    export function center(a: Point, b: Point): {
        x: number;
        y: number;
    };
}

/**
 * Prints to the console.
 *
 * @param args - Arguments to print
 * @public
 */
export declare function print(...args: any[]): void;

export declare type PropertyControls<ComponentProps = any, ArrayTypes = any> = {
    [K in keyof ComponentProps]?: ControlDescription<Partial<ComponentProps>, ArrayTypes>;
};

/* Excluded from this release type: PropertyStore */

/* Excluded from this release type: PropertyTree */

declare interface Props extends ScrollProps {
}

/* Excluded from this release type: Props_2 */

/**
 * @public
 */
declare interface RadialGradient {
    alpha: number;
    widthFactor: number;
    heightFactor: number;
    centerAnchorX: number;
    centerAnchorY: number;
    start: string;
    end: string;
}

/**
 * @alpha
 */
declare namespace RadialGradient {
    function isRadialGradient(radialGradient: any): radialGradient is RadialGradient;
    function toCSS(radialGradient: RadialGradient): string;
}

declare interface RadiusProperties {
    radius: RadiusValue | Partial<{
        topLeft: RadiusValue;
        topRight: RadiusValue;
        bottomLeft: RadiusValue;
        bottomRight: RadiusValue;
    }>;
}

declare type RadiusValue = number | Animatable<number> | string;

/* Excluded from this release type: ReactComponentDefinition */

/**
 * @public
 */
export declare interface Rect extends Point, Size {
}

/**
 * @beta
 */
export declare namespace Rect {
    export function equals(rect: Rect | null, other: Rect | null): boolean;
    const atOrigin: (size: Size) => {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    const fromTwoPoints: (a: Point, b: Point) => Rect;
    const fromRect: (rect: ClientRect) => Rect;
    const multiply: (rect: Rect, n: number) => Rect;
    const divide: (rect: Rect, n: number) => Rect;
    const offset: (rect: Rect, delta: Partial<Point>) => Rect;
    export function inflate(rect: Rect, value: number): Rect;
    const pixelAligned: (rect: Rect) => Rect;
    const halfPixelAligned: (rect: Rect) => Rect;
    const round: (rect: Rect, decimals?: number) => Rect;
    const roundToOutside: (rect: Rect) => Rect;
    const minX: (rect: Rect) => number;
    const maxX: (rect: Rect) => number;
    const minY: (rect: Rect) => number;
    const maxY: (rect: Rect) => number;
    const positions: (rect: Rect) => {
        minX: number;
        midX: number;
        maxX: number;
        minY: number;
        midY: number;
        maxY: number;
    };
    const center: (rect: Rect) => {
        x: number;
        y: number;
    };
    const fromPoints: (ps: Point[]) => {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    /** Returns a rect containing all input rects */
    const merge: (...rect: Rect[]) => Rect;
    const intersection: (rect1: Rect, rect2: Rect) => Rect;
    /** Returns all the corner points for a rect */
    const points: (rect: Rect) => Point[];
    /** Returns wether a rect contains a point */
    const containsPoint: (rect: Rect, point: Point) => boolean;
    /** Returns wether a rect contains another rect entirely */
    const containsRect: (rectA: Rect, rectB: Rect) => boolean;
    const toCSS: (rect: Rect) => {
        display: string;
        transform: string;
        width: string;
        height: string;
    };
    const inset: (rect: Rect, n: number) => {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    const intersects: (rectA: Rect, rectB: Rect) => boolean;
    const overlapHorizontally: (rectA: Rect, rectB: Rect) => boolean;
    const overlapVertically: (rectA: Rect, rectB: Rect) => boolean;
    const doesNotIntersect: (rect: Rect, rects: Rect[]) => boolean;
    const isEqual: (rectA: Rect | null, rectB: Rect | null) => boolean;
    const cornerPoints: (rect: Rect) => Point[];
    const midPoints: (rect: Rect) => Point[];
    const pointDistance: (rect: Rect, point: Point) => number;
    const fromAny: (rect: any, defaults?: {
        x: number;
        y: number;
        width: number;
        height: number;
    }) => Rect;
}

/* Excluded from this release type: RenderEnvironment */

/* Excluded from this release type: RenderTarget */

/**
 * Scroll Component
 * @public
 */
export declare class Scroll extends React.Component<Partial<Props>> {
    static _stylableContainer: boolean;
    static supportsConstraints: boolean;
    static scrollProps: ScrollProps;
    static defaultProps: FrameProperties_2 & ScrollProps;
    static propertyControls: PropertyControls<ScrollProps>;
    draggable: any | null;
    readonly properties: Props;
    private wrapHandlers;
    render(): JSX.Element;
}

declare type ScrollEventHandler = (event: FramerEvent, scrollComponent: Scroll) => void;

declare interface ScrollEvents {
    onScrollStart: ScrollEventHandler;
    onScroll: ScrollEventHandler;
    onScrollEnd: ScrollEventHandler;
    onScrollSessionStart: ScrollEventHandler;
    onScrollSessionEnd: ScrollEventHandler;
}

declare interface ScrollProps extends Partial<ScrollEvents>, Partial<DraggableFrameSpecificProps> {
    draggingEnabled: boolean;
    direction: "horizontal" | "vertical" | "both";
    directionLock: boolean;
    mouseWheel: boolean;
    contentOffsetX: number | Animatable<number> | null;
    contentOffsetY: number | Animatable<number> | null;
}

declare interface SegmentedEnumControlDescription<P = any> extends BaseControlDescription<P> {
    type: ControlType.SegmentedEnum;
    defaultValue?: string;
    options: string[];
    optionTitles?: string[] | ((props: P | null) => string[]);
}

/* Excluded from this release type: serverURL */

/* Excluded from this release type: setGlobalRenderEnvironment */

declare interface Shadow {
    color: string;
    x: number;
    y: number;
    blur: number;
}

declare namespace Shadow {
    function is(shadow: any): shadow is Shadow;
}

/**
 * @public
 */
export declare function Size(width: number, height: number): {
    width: number;
    height: number;
};

/**
 * @public
 */
export declare interface Size {
    width: number;
    height: number;
}

/**
 * @beta
 */
export declare namespace Size {
    const equals: (sizeA: Size | null, sizeB: Size | null) => boolean;
    const update: (fromSize: Size, toSize: Partial<Size>, keepAspectRatio?: boolean) => {
        width: number;
        height: number;
    };
    export function subtract(sizeA: Size, sizeB: Size): {
        width: number;
        height: number;
    };
    const zero: {
        width: number;
        height: number;
    };
    const isZero: (size: Size) => boolean;
    const defaultIfZero: (width: number, height: number, size: Size) => Size;
}

/* Excluded from this release type: SpringAnimator */

declare type SpringOptions = TensionFrictionSpringOptions | DampingDurationSpringOptions;

/* Excluded from this release type: Stack */

/* Excluded from this release type: StackAlignment */

/* Excluded from this release type: StackDirection */

/* Excluded from this release type: StackDistribution */

/* Excluded from this release type: StackPlaceHolders */

/* Excluded from this release type: StackProperties */

/* Excluded from this release type: StackSpecificProps */

/* Excluded from this release type: StackState */

/* Excluded from this release type: State */

/* Excluded from this release type: State_2 */

declare interface StringControlDescription<P = any> extends BaseControlDescription<P> {
    type: ControlType.String;
    defaultValue?: string;
    placeholder?: string;
}

/* Excluded from this release type: StrokeAlignment */

/* Excluded from this release type: SVG */

/* Excluded from this release type: SVGProperties */

/* Excluded from this release type: SVGProps */

declare interface TensionFrictionSpringOptions {
    tension: number;
    friction: number;
    tolerance: number;
    velocity: number;
}

/* Excluded from this release type: Text */

/* Excluded from this release type: TextAlignment */

declare interface TextColorProperties {
    color: Color | string;
}

/* Excluded from this release type: TextProperties */

/* Excluded from this release type: TextProps */

declare type ToAnimatableOrValue<PossiblyAnimatable> = PossiblyAnimatable extends Animatable<infer Value> ? Value | Animatable<Value> : PossiblyAnimatable | Animatable<PossiblyAnimatable>;

/**
 * @public
 */
declare type TransactionId = number;

/**
 * @public
 */
export declare function transform<InputValue, OutputValue>(from: [InputValue, InputValue], to: [OutputValue, OutputValue], options?: Partial<transform.Options<InputValue, OutputValue>>): (from: InputValue) => OutputValue;

/**
 * @public
 */
export declare namespace transform {
    export interface Options<InputValue, OutputValue> {
        inputInterpolation: Interpolation<InputValue>;
        outputInterpolation: Interpolation<OutputValue>;
        limit: boolean;
        colorModel: ColorMixModelType;
    }
    export function value<InputValue, OutputValue>(input: InputValue, from: [InputValue, InputValue], to: [OutputValue, OutputValue], options?: Partial<transform.Options<InputValue, OutputValue>>): OutputValue;
}

declare interface TransformProperties {
    z: Animatable<number> | number;
    rotation: Animatable<number> | number;
    rotationX: Animatable<number> | number;
    rotationY: Animatable<number> | number;
    rotationZ: Animatable<number> | number;
    scale: Animatable<number> | number;
    scaleX: Animatable<number> | number;
    scaleY: Animatable<number> | number;
    scaleZ: Animatable<number> | number;
    skew: Animatable<number> | number;
    skewX: Animatable<number> | number;
    skewY: Animatable<number> | number;
    originX: Animatable<number> | number;
    originY: Animatable<number> | number;
    originZ: Animatable<number> | number;
}

declare const updateComponentLoader: (script: string, framer: any) => void;

/**
 * @public
 */
declare type UpdateFunction<Value> = (change: Change<Value>, transaction?: TransactionId) => void;

/**
 * @public
 */
declare interface UpdateObserver<Value> {
    onUpdate(handler: Observer<Value>): Cancel;
}

/* Excluded from this release type: UserConstraintValues */

/**
 * @public
 */
export declare class ValueInterpolation implements Interpolation {
    private options;
    /* Excluded from this release type: __constructor */
    /* Excluded from this release type: interPolationForValue */
    /* Excluded from this release type: interpolate */
    /* Excluded from this release type: difference */
}

/* Excluded from this release type: Vector */

/* Excluded from this release type: VectorGroup */

/* Excluded from this release type: VectorGroupProperties */

/* Excluded from this release type: VectorGroupProps */

/* Excluded from this release type: VectorProperties */

/* Excluded from this release type: VectorProps */

declare const version = "0.9.7";

declare type VisualProperties = Partial<BackgroundProperties & RadiusProperties & FilterProperties & BackgroundFilterProperties & BlendingProperties & OverflowProperties & BoxShadowProperties & WithOpacity & TextColorProperties>;

declare interface WithEventsProperties extends WithPanHandlers, WithTapHandlers, WithMouseHandlers, WithMouseWheelHandler {
}

/**
 * @public
 */
declare interface WithFractionOfFreeSpace {
    /* Excluded from this release type: freeSpaceInParent */
    /* Excluded from this release type: freeSpaceUnitDivisor */
}

declare interface WithMouseHandlers {
    onMouseDown: EventHandler;
    onClick: EventHandler;
    onMouseUp: EventHandler;
}

declare interface WithMouseWheelHandler {
    onMouseWheelStart: EventHandler;
    onMouseWheel: EventHandler;
    onMouseWheelEnd: EventHandler;
}

/* Excluded from this release type: WithNavigator */

declare interface WithOpacity {
    opacity: number | Animatable<number>;
}

/* Excluded from this release type: WithOverride */

/* Excluded from this release type: WithPackage */

declare interface WithPanHandlers {
    onPanStart: EventHandler;
    onPan: EventHandler;
    onPanEnd: EventHandler;
}

/* Excluded from this release type: WithPath */

declare interface WithTapHandlers {
    onTapStart: EventHandler;
    onTap: EventHandler;
    onTapEnd: EventHandler;
}
