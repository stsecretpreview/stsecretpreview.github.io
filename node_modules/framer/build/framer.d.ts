// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   react
//   immutable
//   draft-js
//   eventemitter3

declare module 'framer' {
    export { Animatable, AnimatableObject, Cancel } from "framer/types/src/animation/Animatable";
    export { animate } from "framer/types/src/animation/animate";
    export { FramerAnimation } from "framer/types/src/animation/FramerAnimation";
    export { Bezier, Spring } from "framer/types/src/animation/Animators";
    import * as events from "framer/types/src/events";
    export { FramerEvent, FramerEventListener, FramerEventSession } from "framer/types/src/events";
    export { Frame, FrameProperties, Scroll, Page, Draggable, Stack, Navigation } from "framer/types/src/components";
    export { WithNavigator } from "framer/types/src/components/hoc/WithNavigator";
    export { Device, DeviceProperties, DeviceDescriptor, DeviceSkin, DeviceSkins } from "framer/types/src/components/devices/Device";
    export { AnyInterpolation, ValueInterpolation, transform } from "framer/types/src/interpolation";
    export * from "framer/types/src/components/devices/Devices";
    export { Point, Size, Rect, Vector, VectorGroup, ComponentContainer, SVG, Text, componentLoader, setGlobalRenderEnvironment, RenderTarget, ControlType, PropertyControls, updateComponentLoader, getURLs, serverURL, NavigationLink, isReactDefinition, createDesignComponent, CanvasStore, isOverride, } from "framer/types/src/render";
    export { events };
    export { ObservableObject } from "framer/types/src/data/ObservableObject";
    export { Data } from "framer/types/src/data/Data";
    export { Override, OverrideFunction, OverrideObject, WithOverride } from "framer/types/src/data/WithOverride";
    export { DataObserver } from "framer/types/src/data/DataObserver";
    export { PropertyStore } from "framer/types/src/data/PropertyStore";
    export { loadJSON } from "framer/types/src/utils/network";
    export { print } from "framer/types/src/utils/print";
    import { MainLoop } from "framer/types/src/core/Loop";
    export { MainLoop };
}

declare module 'framer/types/src/animation/Animatable' {
    export { Animatable, AnimatableObject, Cancel, Change, isAnimatable } from "framer/types/src/animation/Animatable/Animatable";
    export { UpdateObserver } from "framer/types/src/animation/Animatable/Observers";
}

declare module 'framer/types/src/animation/animate' {
    import { FramerAnimation, AnimationOptions } from "framer/types/src/animation/FramerAnimation";
    import { SpringOptions } from "framer/types/src/animation/Animators";
    import { Animatable, AnimatableObject } from "framer/types/src/animation/Animatable";
    import { AnimatorClass } from "framer/types/src/animation/Animators/Animator";
    import { BezierOptions } from "framer/types/src/animation/Animators/BezierAnimator";
    export function animate<Value, Options>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, animator?: AnimatorClass<Value, Options>, options?: Partial<Options & AnimationOptions<Value>>): FramerAnimation<Value, Options>;
    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
    export type EaseOptions = Omit<BezierOptions, "curve">;
    export namespace animate {
        function spring<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<SpringOptions & AnimationOptions<Value>>): FramerAnimation<Value, SpringOptions>;
        function bezier<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<BezierOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
        function linear<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<EaseOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
        function ease<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<EaseOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
        function easeIn<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<EaseOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
        function easeOut<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<EaseOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
        function easeInOut<Value>(from: Animatable<Value> | AnimatableObject<Value>, to: Value, options?: Partial<EaseOptions & AnimationOptions<Value>>): FramerAnimation<Value, BezierOptions>;
    }
}

declare module 'framer/types/src/animation/FramerAnimation' {
    import { Animator as AnimatorInterface, AnimatorClass } from "framer/types/src/animation/Animators/Animator";
    import { Interpolation, InterpolationOptions } from "framer/types/src/interpolation";
    import { Animatable, AnimatableObject } from "framer/types/src/animation/Animatable";
    import { DriverClass, AnimationDriver } from "framer/types/src/animation/Drivers/AnimationDriver";
    export type FramerAnimationState = "idle" | "running" | "finished";
    export interface AnimationOptions<Value> extends InterpolationOptions {
        customInterpolation?: Interpolation<Value>;
        precalculate: boolean;
    }
    export class FramerAnimation<Value, AnimatorOptions> {
        driver: AnimationDriver<AnimatorInterface<Value, AnimatorOptions>, Value, AnimatorOptions>;
        constructor(target: Animatable<Value> | AnimatableObject<Value>, from: Value, to: Value, animatorClass?: AnimatorClass<Value, AnimatorOptions>, options?: Partial<AnimatorOptions & AnimationOptions<Value>>, driverClass?: DriverClass<AnimatorInterface<Value, AnimatorOptions>, Value, AnimatorOptions>);
        protected static driverCallbackHandler<Value>(target: Animatable<Value> | AnimatableObject<Value>, value: Value): void;
        protected playStateSource: FramerAnimationState;
        protected playStateValue: FramerAnimationState;
        readonly playState: FramerAnimationState;
        onfinish: undefined | (() => void);
        oncancel: undefined | (() => void);
        protected readyPromise: Promise<void>;
        protected readyResolve: null | (() => void);
        protected resetReadyPromise(): void;
        readonly ready: Promise<void>;
        protected finishedPromise: Promise<void>;
        protected finishedResolve: null | (() => void);
        protected finishedReject: null | ((reason: any) => void);
        protected resetFinishedPromise(): void;
        readonly finished: Promise<void>;
        play(): void;
        cancel(): void;
        finish(): void;
        isFinished(): boolean;
    }
}

declare module 'framer/types/src/animation/Animators' {
    export { FrictionAnimator as Friction, Options as FrictionOptions } from "framer/types/src/animation/Animators/FrictionAnimator";
    export { SpringAnimator as Spring, SpringOptions } from "framer/types/src/animation/Animators/SpringAnimator";
    export { BezierAnimator as Bezier, BezierOptions as BezierOptions } from "framer/types/src/animation/Animators/BezierAnimator";
    export { InertialScrollAnimator as InertialScroll, Options as InertialScrollOptions } from "framer/types/src/animation/Animators/InertialScrollAnimator";
}

declare module 'framer/types/src/events' {
    export { FramerEventListener } from "framer/types/src/events/FramerEventListener";
    export { FramerEvent } from "framer/types/src/events/FramerEvent";
    export { FramerEventSession } from "framer/types/src/events/FramerEventSession";
}

declare module 'framer/types/src/components' {
    export { Frame, FrameProperties } from "framer/types/src/components/Frame";
    export { Scroll } from "framer/types/src/components/Scroll";
    export { Screen } from "framer/types/src/components/Screen";
    export { Navigation } from "framer/types/src/components/Navigation";
    export { Draggable } from "framer/types/src/components/Draggable";
    export { Device } from "framer/types/src/components/devices/Device";
    export { Page } from "framer/types/src/components/Page";
    export { Stack } from "framer/types/src/components/Stack";
}

declare module 'framer/types/src/components/hoc/WithNavigator' {
    import * as React from "react";
    import { Navigator } from "framer/types/src/components/Navigation";
    import { NavigationTransitionDirection } from "framer/types/src/render";
    export interface WithNavigator {
        navigator: null | Navigator;
    }
    export function WithNavigator<T, BaseProps extends React.ClassAttributes<T> & WithNavigator>(BaseComponent: React.ComponentType<BaseProps & {
        onTap?: any;
    }>, navigationTransition: string, navigationTransitionDirection: NavigationTransitionDirection, navigationComponent: (() => React.ReactNode) | undefined): React.ComponentClass<BaseProps & WithNavigator>;
}

declare module 'framer/types/src/components/devices/Device' {
    import * as React from "react";
    import { DeviceRegistry } from "framer/types/src/components/devices/DeviceRegisty";
    import { Size } from "framer/types/src/render/types/Size";
    import { AnimatableObject } from "framer/types/src/animation/Animatable";
    import { DeviceRenderer } from "framer/types/src/components/devices/DeviceRenderer";
    import { DeviceSkins } from "framer/types/src/components/devices/DeviceSkin";
    import { DeviceHands } from "framer/types/src/components/devices/DeviceHand";
    export * from "framer/types/src/components/devices/DeviceSkin";
    export * from "framer/types/src/components/devices/DeviceHand";
    export interface DeviceProperties {
        parentSize: null | AnimatableObject<Size>;
        deviceSize: Size;
        contentSize: Size;
        skin?: string;
        hand?: string;
        zoom: number;
        responsive: boolean;
        rotate?: boolean;
        background?: string;
        onRequirePackage: (pakkage: string, displayName: string) => void;
        renderer: typeof DeviceRenderer;
    }
    export interface DeviceDescriptor {
        title: string;
        category?: string;
        selector?: string;
        kind?: string;
        skins: DeviceSkins;
        hands: DeviceHands;
        screen: Size;
        pixelRatio?: number;
        canRotate?: boolean;
    }
    export class Device extends React.Component<Partial<DeviceProperties>> {
        static defaultProps: DeviceProperties;
        static registry: DeviceRegistry;
        static descriptor: DeviceDescriptor;
        readonly descriptor: DeviceDescriptor;
        readonly skins: DeviceSkins;
        readonly hands: DeviceHands;
        readonly svgScreenMask: string | undefined;
        readonly properties: DeviceProperties;
        componentDidMount(): void;
        componentDidUpdate(prevProps: DeviceProperties): void;
        computeRequiredPackages(): void;
        render(): JSX.Element;
    }
}

declare module 'framer/types/src/interpolation' {
    export { Interpolation } from "framer/types/src/interpolation/Interpolation";
    export { ValueInterpolation, AnyInterpolation, InterpolationOptions } from "framer/types/src/interpolation/ValueInterpolation";
    export { NumberInterpolation } from "framer/types/src/interpolation/NumberInterpolation";
    export { ObjectInterpolation } from "framer/types/src/interpolation/ObjectInterpolation";
    export { NoInterpolation } from "framer/types/src/interpolation/NoInterpolation";
    export { ColorInterpolation } from "framer/types/src/interpolation/ColorInterpolation";
    export { transform } from "framer/types/src/interpolation/transform";
}

declare module 'framer/types/src/components/devices/Devices' {
    import { Device } from "framer/types/src/components/devices/Device";
    export const FramerAppleWatch38: typeof Device;
    export const FramerAppleWatch42: typeof Device;
    export const FramerSonySmartWatch: typeof Device;
    export const FramerAppleIPhoneSE: typeof Device;
    export const FramerAppleIPhone8: typeof Device;
    export const FramerAppleIPhone8Plus: typeof Device;
    export const FramerAppleIPhoneX: typeof Device;
    export const FramerGoogleNexus4: typeof Device;
    export const FramerGoogleNexus5X: typeof Device;
    export const FramerGoogleNexus6: typeof Device;
    export const FramerGooglePixel2: typeof Device;
    export const FramerGooglePixel2XL: typeof Device;
    export const FramerHTCOneA9: typeof Device;
    export const FramerMicrosoftLumia950: typeof Device;
    export const FramerSamsungNote5: typeof Device;
    export const FramerSamsungGalaxyS8: typeof Device;
    export const FramerAppleIPadAir: typeof Device;
    export const FramerAppleIPadMini: typeof Device;
    export const FramerAppleIPadPro: typeof Device;
    export const FramerGoogleNexusTablet: typeof Device;
    export const FramerMicrosoftSurfacePro3: typeof Device;
    export const FramerMicrosoftSurfacePro4: typeof Device;
    export const FramerAppleIMac: typeof Device;
    export const FramerAppleThunderboltDisplay: typeof Device;
    export const FramerAppleMacBook: typeof Device;
    export const FramerAppleMacBookAir: typeof Device;
    export const FramerAppleMacBookPro: typeof Device;
    export const FramerDellXPS: typeof Device;
    export const FramerMicrosoftSurfaceBook: typeof Device;
    export const FramerSonyW850C: typeof Device;
}

declare module 'framer/types/src/render' {
    export { LineJoin, LineCap } from "framer/types/src/render/types/Stroke";
    export { collectFiltersFromProps } from "framer/types/src/render/utils/filtersForNode";
    export { getURLs } from "framer/types/src/render/utils/getURLs";
    export { serverURL } from "framer/types/src/render/utils/serverURL";
    export { memoize } from "framer/types/src/utils/memoize";
    export { InternalID } from "framer/types/src/utils/internalId";
    export { LinearGradientElementProperties } from "framer/types/src/render/utils/elementPropertiesForLinearGradient";
    export { frameFromElement, frameFromElements, dispatchKeyDownEvent, DOM } from "framer/types/src/render/utils/dom";
    export { FillProperties } from "framer/types/src/render/traits/Fill";
    export { FilterProperties, FilterNumberProperties } from "framer/types/src/render/traits/Filters";
    export { BackgroundFilterProperties } from "framer/types/src/render/traits/BackdropFilters";
    export { RadiusProperties } from "framer/types/src/render/traits/Radius";
    export { BlendingProperties, BlendingMode, collectBlendingFromProps } from "framer/types/src/render/traits/Blending";
    export { Background } from "framer/types/src/render/traits/Background";
    export { ImageFit, BackgroundImage } from "framer/types/src/render/types/BackgroundImage";
    export { WithOpacity, withOpacity, collectOpacityFromProps } from "framer/types/src/render/traits/Opacity";
    export { VisualProperties, collectVisualStyleFromProps } from "framer/types/src/render/style/collectVisualStyleFromProps";
    export { WithShape, withShape } from "framer/types/src/render/traits/Shape";
    export { BoxShadowProperties } from "framer/types/src/render/traits/BoxShadow";
    export { gradientForShape } from "framer/types/src/render/utils/gradientForShape";
    export { debounce } from "framer/types/src/render/utils/debounce";
    export { setImageForFill, imageUrlForFill, imageUrlForAsset, QualityOptions } from "framer/types/src/render/utils/imageForFill";
    export { _imageURL, _imageScalingMethod } from "framer/types/src/render/utils/imageForFill";
    export { imagePatternPropsForFill } from "framer/types/src/render/utils/imagePatternPropsForFill";
    export { componentLoader, updateComponentLoader, ComponentDefinition, isReactDefinition, isOverride, componentIdentifierForMasterId, } from "framer/types/src/render/utils/componentLoader";
    export { BooleanControlDescription, NumberControlDescription, StringControlDescription, FusedNumberControlDescription, EnumControlDescription, SegmentedEnumControlDescription, ColorControlDescription, ImageControlDescription, FileControlDescription, ChildrenControlDescription, ControlType, PropertyControls, } from "framer/types/src/render/types/PropertyControls";
    export { WithFractionOfFreeSpace, supportsFractionOfFreeSpace } from "framer/types/src/render/traits/FreeSpace";
    export { withStylableContainer } from "framer/types/src/render/traits/StylableContainer";
    export { isOfAnnotatedType, annotateTypeOnStringify } from "framer/types/src/render/utils/annotateTypeOnStringify";
    export { PathSegment } from "framer/types/src/render/types/PathSegment";
    export { PathSegments } from "framer/types/src/render/types/PathSegments";
    export { WithPath, withPath, WithPaths, isStraightCurve, pathDefaults, toSVGPath } from "framer/types/src/render/traits/Path";
    export { BoxShadow, Shadow } from "framer/types/src/render/types/Shadow";
    export { StrokeAlignment } from "framer/types/src/render/types/StrokeAlignment";
    export { Rect } from "framer/types/src/render/types/Rect";
    export { Size } from "framer/types/src/render/types/Size";
    export { Line } from "framer/types/src/render/types/Line";
    export { Point } from "framer/types/src/render/types/Point";
    export { Gradient, LinearGradient, RadialGradient } from "framer/types/src/render/types/Gradient";
    export { Frame, FrameProperties } from "framer/types/src/render/presentation/Frame";
    export { Layer, LayerProps, IdentityProps } from "framer/types/src/render/presentation/Layer";
    export { SVG, SVGProperties } from "framer/types/src/render/presentation/SVG";
    export { Text, TextProperties, TextAlignment } from "framer/types/src/render/presentation/Text";
    export { Vector, VectorProperties } from "framer/types/src/render/presentation/Vector";
    export { VectorGroup, VectorGroupProperties } from "framer/types/src/render/presentation/VectorGroup";
    export { ComponentContainer, ComponentContainerProperties } from "framer/types/src/render/presentation/ComponentContainer";
    export { TextBlock, draftBlockRendererFunction } from "framer/types/src/render/presentation/TextBlock";
    export { TransformValues } from "framer/types/src/render/types/TransformValues";
    export { DefaultProps, ConstraintMask, ConstraintValues, ConstraintProperties, ConstraintPercentage, DimensionType, valueToDimensionType, } from "framer/types/src/render/types/Constraints";
    export { Color, ConvertColor } from "framer/types/src/render/types/Color";
    export { BorderStyle } from "framer/types/src/render/style/border";
    export { draftStyleFunction, draftStyles, getStyleForTypefaceOrSelector } from "framer/types/src/render/style/draft";
    export { isEqual } from "framer/types/src/render/utils/isEqual";
    export { isFiniteNumber, finiteNumber } from "framer/types/src/render/utils/isFiniteNumber";
    export { roundedNumber, roundedNumberString, roundWithOffset } from "framer/types/src/render/utils/roundedNumber";
    export { transformString } from "framer/types/src/render/utils/transformString";
    export { localShadowFrame, shadowForShape } from "framer/types/src/render/style/shadow";
    export { PresentationTree, renderPresentationTree, convertPresentationTree } from "framer/types/src/render/presentation/PresentationTree";
    export { RenderTarget, executeInRenderEnvironment, setGlobalRenderEnvironment } from "framer/types/src/render/types/RenderEnvironment";
    export { NavigateTo, NavigationLink, NavigationTarget, NavigationTransition, NavigationTransitionDirection, } from "framer/types/src/render/types/NavigationLink";
    export { WithChildInsertion, withChildInsertion } from "framer/types/src/render/traits/ChildInsertion";
    export { ChildLayoutProvider, providesChildLayout } from "framer/types/src/render/traits/ChildLayoutProvider";
    export { FreeSpaceProvider, providesFreeSpace, toFreeSpace } from "framer/types/src/render/traits/FreeSpaceProvider";
    export { AutoSize, hasAutoSize } from "framer/types/src/render/traits/AutoSize";
    export { WithCSSExport, withCSSExport } from "framer/types/src/render/traits/CSSExport";
    export { PaddingSizeProvider, toPaddingSize } from "framer/types/src/render/traits/PaddingSize";
    import * as f from "framer/types/src/render/config/fonts";
    export const fonts: typeof f;
    import { collectBorderStyleForProps } from "framer/types/src/render/style/border";
    export const styles: {
        collectBorder: typeof collectBorderStyleForProps;
    };
    export { createDesignComponent, CanvasStore, PropertyTree } from "framer/types/src/render/DesignComponentWrapper";
}

declare module 'framer/types/src/data/ObservableObject' {
    import { Observer } from "framer/types/src/animation/Animatable/Observers";
    import { Cancel, AnimatableObject } from "framer/types/src/animation/Animatable";
    function ObservableObject<T extends object = object>(initial?: Partial<T> | object, makeAnimatables?: boolean, observeAnimatables?: boolean): AnimatableObject<T>;
    namespace ObservableObject {
        const addObserver: <T extends object>(target: T, observer: Observer<T>) => Cancel;
    }
    export { ObservableObject };
}

declare module 'framer/types/src/data/Data' {
    import { Observer } from "framer/types/src/animation/Animatable/Observers";
    import { Cancel } from "framer/types/src/animation/Animatable";
    export function Data<T extends object = object>(initial?: Partial<T> | object): T;
    export namespace Data {
        let stores: object[];
        function addData(data: object): void;
        const addObserver: <T extends object>(target: T, observer: Observer<T>) => Cancel;
    }
}

declare module 'framer/types/src/data/WithOverride' {
    import * as React from "react";
    import { FrameProperties } from "framer/types/src/components/Frame";
    export type OverrideObject<T extends object = any> = Partial<T>;
    export type OverrideFunction<P extends object = any> = (props: P) => Partial<P>;
    export type Override<T extends object = FrameProperties & {
        [key: string]: any;
    }> = OverrideObject<T> | OverrideFunction<T>;
    export function WithOverride<T extends object>(Component: React.ComponentType<T>, override: Override<T>): (props: T) => JSX.Element;
}

declare module 'framer/types/src/data/DataObserver' {
    import * as React from "react";
    import { Cancel } from "framer/types/src/animation/Animatable";
    export interface Props {
    }
    export interface State {
        update: number;
    }
    export const DataObserverContext: React.Context<{
        update: number;
    }>;
    export class DataObserver extends React.Component<Props, State> {
        observers: Cancel[];
        state: {
            update: number;
        };
        static getDerivedStateFromProps(nextProps: Props, prevState: State): State | null;
        render(): JSX.Element;
    }
}

declare module 'framer/types/src/data/PropertyStore' {
    import { Observer } from "framer/types/src/animation/Animatable/Observers";
    import { Cancel, AnimatableObject } from "framer/types/src/animation/Animatable";
    export function PropertyStore<T extends object = object>(initial?: Partial<T> | object, makeAnimatables?: boolean): AnimatableObject<T>;
    export namespace PropertyStore {
        const addObserver: <T extends object>(target: T, observer: Observer<T>) => Cancel;
    }
}

declare module 'framer/types/src/utils/network' {
    export function loadJSON<T>(url: string): Promise<T>;
}

declare module 'framer/types/src/utils/print' {
    export function print(...args: any[]): void;
}

declare module 'framer/types/src/core/Loop' {
    import { EventEmitter } from "framer/types/src/core/EventEmitter";
    export type LoopEventNames = "render" | "update" | "finish";
    export type LoopDeltaCallback = (this: Loop, frame: number) => void;
    export class Loop extends EventEmitter<LoopEventNames> {
        static TimeStep: number;
        constructor(start?: boolean);
        start(): this;
        stop(): this;
        readonly frame: number;
        readonly time: number;
    }
    export const MainLoop: Loop;
}

declare module 'framer/types/src/animation/Animatable/Animatable' {
    import { UpdateObserver, FinishFunction } from "framer/types/src/animation/Animatable/Observers";
    export type Cancel = () => void;
    export type TransactionId = number;
    export interface Change<Value> {
        value: Value;
        oldValue?: Value;
    }
    export type ToAnimatable<PossiblyAnimatable> = PossiblyAnimatable extends Animatable<infer Value> ? Animatable<Value> : Animatable<PossiblyAnimatable>;
    export type FromAnimatable<PossiblyAnimatable> = PossiblyAnimatable extends Animatable<infer Value> ? Value : PossiblyAnimatable;
    export type ToAnimatableOrValue<PossiblyAnimatable> = PossiblyAnimatable extends Animatable<infer Value> ? Value | Animatable<Value> : PossiblyAnimatable | Animatable<PossiblyAnimatable>;
    export type AnimatableObject<T> = {
        [K in keyof T]: ToAnimatableOrValue<T[K]>;
    };
    export interface Animatable<Value> extends UpdateObserver<Value> {
        get(): Value;
        set(value: Value | Animatable<Value>, transaction?: TransactionId): void;
        finishTransaction(transaction: TransactionId): FinishFunction[];
    }
    export function Animatable<Value>(value: Value | Animatable<Value>): Animatable<Value>;
    export namespace Animatable {
        function transaction(update: (updater: (animatable: Animatable<any>, value: any) => void, transactionId: TransactionId) => void): void;
        function getNumber(value: number | Animatable<number> | null | undefined, defaultValue?: number): number;
        function get<Value>(value: Value | Animatable<Value> | null | undefined, defaultValue: Value): Value;
        function objectToValues<Object>(object: AnimatableObject<Object>): Object;
    }
    export function isAnimatable(value: any): value is Animatable<any>;
}

declare module 'framer/types/src/animation/Animatable/Observers' {
    import { Cancel, TransactionId, Change } from "framer/types/src/animation/Animatable/Animatable";
    export type UpdateFunction<Value> = (change: Change<Value>, transaction?: TransactionId) => void;
    export type FinishFunction = (transaction: TransactionId) => void;
    export type Observer<Value> = {
        update: UpdateFunction<Value>;
        finish: FinishFunction;
    } | UpdateFunction<Value>;
    export interface UpdateObserver<Value> {
        onUpdate(handler: Observer<Value>): Cancel;
    }
    export class Observers<Value> {
        add(observer: Observer<Value>): Cancel;
        notify(change: Change<Value>, transaction?: TransactionId): void;
        finishTransaction(transaction: TransactionId): FinishFunction[];
    }
}

declare module 'framer/types/src/animation/Animators/Animator' {
    import { Interpolation } from "framer/types/src/interpolation/Interpolation";
    export interface Animator<Value, Options = any> {
        setFrom(from: Value): void;
        setTo(to: Value): void;
        isReady(): boolean;
        next(delta: number): Value;
        isFinished(): boolean;
    }
    export interface AnimatorClass<Value, Options = any> {
        new (options: Partial<Options>, interpolation: Interpolation<Value>): Animator<Value, Options>;
    }
}

declare module 'framer/types/src/animation/Animators/BezierAnimator' {
    import { Animator } from "framer/types/src/animation/Animators/Animator";
    import { Interpolation, Interpolator } from "framer/types/src/interpolation/Interpolation";
    export enum Bezier {
        Linear = "linear",
        Ease = "ease",
        EaseIn = "ease-in",
        EaseOut = "ease-out",
        EaseInOut = "ease-in-out"
    }
    export const BezierDefaults: BezierOptions;
    export type ControlPoints = [number, number, number, number];
    export type Curve = ControlPoints | Bezier;
    export interface BezierOptions {
        curve: Curve;
        duration: number;
    }
    export class BezierAnimator<Value> implements Animator<Value, BezierOptions> {
        current: Value;
        destination: Value;
        interpolator: Interpolator<Value>;
        progress: number;
        constructor(options: Partial<BezierOptions>, interpolation: Interpolation<Value>);
        setFrom(value: Value): void;
        setTo(value: Value): void;
        isReady(): boolean;
        updateInterpolator(): void;
        next: (delta: number) => Value;
        isFinished(): boolean;
        solveEpsilon(duration: number): number;
    }
}

declare module 'framer/types/src/animation/Drivers/AnimationDriver' {
    import { Animator as AnimatorInterface } from "framer/types/src/animation/Animators/Animator";
    export interface DriverClass<Animator extends AnimatorInterface<Value, Options>, Value, Options = any> {
        new (animator: Animator, updateCallback: (value: Value) => void, doneCallback?: (isFinished: boolean) => void): AnimationDriver<Animator, Value, Options>;
    }
    export abstract class AnimationDriver<Animator extends AnimatorInterface<Value, Options>, Value, Options> {
        animator: Animator;
        protected updateCallback: (value: Value) => void;
        protected finishedCallback?: ((isFinished: boolean) => void) | undefined;
        constructor(animator: Animator, updateCallback: (value: Value) => void, finishedCallback?: ((isFinished: boolean) => void) | undefined);
        abstract play(): void;
        protected update: (frame: number, elapsed: number) => void;
        abstract cancel(): void;
        finish(): void;
        isFinished(): boolean;
    }
}

declare module 'framer/types/src/animation/Animators/FrictionAnimator' {
    import { State } from "framer/types/src/animation/Animators/Integrator";
    import { Animator } from "framer/types/src/animation/Animators/Animator";
    export type Options = {
        velocity: number;
        friction: number;
        tolerance: number;
    };
    export class FrictionAnimator implements Animator<number, Partial<Options>> {
        options: Options;
        constructor(options: Partial<Options>);
        setFrom(value: number): void;
        setTo(value: number): void;
        setVelocity(velocity: number): void;
        getState(): State;
        isReady(): boolean;
        next(delta: number): number;
        isFinished(): boolean;
    }
}

declare module 'framer/types/src/animation/Animators/SpringAnimator' {
    import { State } from "framer/types/src/animation/Animators/Integrator";
    import { Animator } from "framer/types/src/animation/Animators/Animator";
    import { Interpolation } from "framer/types/src/interpolation/Interpolation";
    export const SpringTensionFrictionDefaults: {
        tension: number;
        friction: number;
        tolerance: number;
        velocity: number;
    };
    export const SpringDampingDurationDefaults: {
        dampingRatio: number;
        duration: number;
        velocity: number;
        mass: number;
    };
    export type TensionFrictionSpringOptions = typeof SpringTensionFrictionDefaults;
    export type DampingDurationSpringOptions = typeof SpringDampingDurationDefaults;
    export type SpringOptions = TensionFrictionSpringOptions | DampingDurationSpringOptions;
    export class SpringAnimator<Value> implements Animator<Value, SpringOptions> {
        constructor(options: Partial<SpringOptions>, interpolation: Interpolation<Value>);
        isReady(): boolean;
        next(delta: number): Value;
        isFinished(): boolean;
        setFrom(value: Value): void;
        setVelocity(velocity: number): void;
        progress(): number;
        setTo(value: Value): void;
        getState(): State;
        updateInterpolator(): void;
    }
}

declare module 'framer/types/src/animation/Animators/InertialScrollAnimator' {
    import { Animator } from "framer/types/src/animation/Animators/Animator";
    import { State } from "framer/types/src/animation/Animators/Integrator";
    import { FrictionAnimator } from "framer/types/src/animation/Animators/FrictionAnimator";
    import { SpringAnimator } from "framer/types/src/animation/Animators/SpringAnimator";
    export const Defaults: {
        velocity: number;
        min: number;
        max: number;
        momentum: {
            friction: number;
            tolerance: number;
        };
        bounce: {
            tension: number;
            friction: number;
            tolerance: number;
        };
    };
    export type Options = typeof Defaults;
    export class InertialScrollAnimator implements Animator<number, Options> {
        constructor(options: Partial<Options>);
        isReady(): boolean;
        next(delta: number): number;
        readonly currentAnimator: SpringAnimator<number> | FrictionAnimator;
        isFinished(): boolean;
        readonly state: State;
        setFrom(value: number): void;
        setState(state: State): void;
        setTo(destination: number): void;
        setLimits(min: number, max: number): void;
    }
}

declare module 'framer/types/src/events/FramerEventListener' {
    import { TouchEventListener } from "framer/types/src/events/recognizer/TouchEventListener";
    import { MouseEventListener } from "framer/types/src/events/recognizer/MouseEventListener";
    export const FramerEventListener: typeof TouchEventListener | typeof MouseEventListener;
}

declare module 'framer/types/src/events/FramerEvent' {
    import { EventLike } from "framer/types/src/utils/events";
    import { FramerEventSession } from "framer/types/src/events/FramerEventSession";
    import { Point } from "framer/types/src/render";
    export type EventHandler = (event: FramerEvent) => void;
    export class FramerEvent {
        readonly originalEvent: MouseEvent | TouchEvent;
        readonly session: FramerEventSession;
        readonly time: number;
        readonly loopTime: number;
        readonly point: Point;
        readonly devicePoint: Point;
        readonly target: EventTarget | null;
        readonly delta: Point;
        constructor(originalEvent: MouseEvent | TouchEvent, session: FramerEventSession);
        static eventLikeFromOriginalEvent(originalEvent: MouseEvent | TouchEvent): EventLike;
        velocity(t: number): Point;
        readonly offset: Point;
        readonly isLeftMouseClick: boolean | undefined;
    }
}

declare module 'framer/types/src/events/FramerEventSession' {
    import { Point } from "framer/types/src/render";
    import { FramerEvent } from "framer/types/src/events/FramerEvent";
    import { GestureRecognizer, GestureHandler } from "framer/types/src/events/recognizer/GestureRecognizer";
    import { MouseWheelGestureRecognizer } from "framer/types/src/events/recognizer/MouseWheelGestureRecognizer";
    export type EventDispatcher = ((type: string, event: FramerEvent, target: EventTarget) => void);
    export type NativeEvent = MouseEvent | TouchEvent;
    export class FramerEventSession implements GestureHandler {
        events: FramerEvent[];
        recognizers: GestureRecognizer[];
        mouseWheelRecognizer: MouseWheelGestureRecognizer;
        dispatcher: EventDispatcher;
        originElement: HTMLElement;
        readonly isStarted: boolean;
        readonly startEvent: FramerEvent | null;
        readonly lastEvent: FramerEvent | null;
        constructor(dispatcher: EventDispatcher, customOrigin?: HTMLElement);
        pointerDown(event: FramerEvent): void;
        pointerMove(event: FramerEvent): void;
        pointerUp(event: FramerEvent): void;
        mouseWheel(event: FramerEvent): void;
        gestureBegan(type: string, event: FramerEvent, target: EventTarget | null): void;
        gestureChanged(type: string, event: FramerEvent, target: EventTarget | null): void;
        gestureEnded(type: string, event: FramerEvent, target: EventTarget | null): void;
        velocity(t?: number): Point;
        offset(event: FramerEvent): Point;
    }
}

declare module 'framer/types/src/components/Frame' {
    import { FrameProperties as CoreFrameProperties } from "framer/types/src/render";
    import { WithEventsProperties } from "framer/types/src/components/hoc/WithEvents";
    export type FrameProperties = CoreFrameProperties & WithEventsProperties;
    export const Frame: React.ComponentClass<Partial<FrameProperties>>;
    export type Frame = React.Component<FrameProperties>;
}

declare module 'framer/types/src/components/Scroll' {
    import { FramerEvent } from "framer/types/src/events/FramerEvent";
    import * as React from "react";
    import { DraggableProps } from "framer/types/src/components/hoc/WithDragging";
    import { FrameProperties, PropertyControls } from "framer/types/src/render";
    import { Frame } from "framer/types/src/components/Frame";
    import { Animatable } from "framer/types/src/animation/Animatable/Animatable";
    type DraggableType = typeof Frame;
    export type DraggableFrameProps = Partial<FrameProperties> & Partial<DraggableProps<DraggableType>>;
    export type ScrollEventHandler = (event: FramerEvent, scrollComponent: Scroll) => void;
    export interface ScrollEvents {
        onScrollStart: ScrollEventHandler;
        onScroll: ScrollEventHandler;
        onScrollEnd: ScrollEventHandler;
        onScrollSessionStart: ScrollEventHandler;
        onScrollSessionEnd: ScrollEventHandler;
    }
    export interface ScrollProps extends Partial<ScrollEvents>, Partial<DraggableFrameProps> {
        contentWidth: number | Animatable<number> | undefined;
        contentHeight: number | Animatable<number> | undefined;
        direction: "horizontal" | "vertical" | "both";
        directionLock: boolean;
        mouseWheel: boolean;
        contentOffsetX: number | Animatable<number> | null;
        contentOffsetY: number | Animatable<number> | null;
    }
    export interface Props extends ScrollProps {
    }
    export class Scroll extends React.Component<Partial<Props>> {
        static _stylableContainer: boolean;
        static supportsConstraints: boolean;
        static scrollProps: ScrollProps;
        static defaultProps: FrameProperties & ScrollProps;
        static propertyControls: PropertyControls;
        draggable: any | null;
        readonly properties: Props;
        render(): JSX.Element;
    }
    export {};
}

declare module 'framer/types/src/components/Screen' {
    import * as React from "react";
    import { FramerEventSession } from "framer/types/src/events/FramerEventSession";
    export interface ScreenProperties {
        width: number;
        height: number;
        scale?: number;
        color?: string;
    }
    export class Screen extends React.Component<ScreenProperties> {
        session: FramerEventSession;
        componentDidMount(): void;
        render(): JSX.Element;
    }
}

declare module 'framer/types/src/components/Navigation' {
    import * as React from "react";
    import { Size } from "framer/types/src/render/types/Size";
    import { NavigationTransition } from "framer/types/src/components/NavigationTransitions";
    import { Rect } from "framer/types/src/render/types/Rect";
    import { FrameProperties } from "framer/types/src/render";
    export interface Navigator {
        goBack: () => void;
        instant: (Component: React.ReactNode) => void;
        fade: (component: React.ReactNode) => void;
        push: (Component: React.ReactNode) => void;
        pushLeft: (Component: React.ReactNode) => void;
        pushRight: (Component: React.ReactNode) => void;
        pushDown: (Component: React.ReactNode) => void;
        pushUp: (Component: React.ReactNode) => void;
        modal: (Component: React.ReactNode) => void;
        overlayTop: (Component: React.ReactNode) => void;
        overlayBottom: (Component: React.ReactNode) => void;
        overlayLeft: (Component: React.ReactNode) => void;
        overlayRight: (Component: React.ReactNode) => void;
        flipUp: (Component: React.ReactNode) => void;
        flipDown: (Component: React.ReactNode) => void;
        flipLeft: (Component: React.ReactNode) => void;
        flipRight: (Component: React.ReactNode) => void;
    }
    export const NavigatorContext: React.Context<Navigator | null>;
    export type NavigationProps = Partial<Rect>;
    export type NavigationItem = {
        key: string;
        component: React.ReactNode;
        transition: NavigationTransition;
    };
    export interface NavigationState {
        current: number;
        previous: number;
    }
    export class Navigation extends React.Component<NavigationProps, NavigationState> implements Navigator {
        stack: NavigationItem[];
        activeTransition: NavigationTransition;
        count: number;
        state: {
            current: number;
            previous: number;
        };
        componentDidMount(): void;
        componentWillReceiveProps(props: NavigationProps): void;
        push: (Component: React.ReactNode, transition?: NavigationTransition) => void;
        goBack: () => void;
        instant: (Component: React.ReactNode) => void;
        fade: (Component: React.ReactNode) => void;
        pushLeft: (Component: React.ReactNode) => void;
        pushRight: (Component: React.ReactNode) => void;
        pushDown: (Component: React.ReactNode) => void;
        pushUp: (Component: React.ReactNode) => void;
        modal: (Component: React.ReactNode) => void;
        overlayTop: (Component: React.ReactNode) => void;
        overlayBottom: (Component: React.ReactNode) => void;
        overlayLeft: (Component: React.ReactNode) => void;
        overlayRight: (Component: React.ReactNode) => void;
        flipUp: (Component: React.ReactNode) => void;
        flipDown: (Component: React.ReactNode) => void;
        flipLeft: (Component: React.ReactNode) => void;
        flipRight: (Component: React.ReactNode) => void;
        contextSize(): Size;
        contentSize(containerIndex: number, contextSize: Size): Size;
        initialPropsForContainer(containerIndex: number, contextSize: Size, contentSize: Size): Partial<FrameProperties>;
        transitionPropsForContainer(containerIndex: number, contextSize: Size, contentSize: Size): Partial<FrameProperties>;
        transitionDurationForContainer(containerIndex: number): number;
        containerIsVisible: (containerIndex: number) => boolean;
        containerShouldHideAfterTransition: (containerIndex: number) => boolean;
        containerContent: (item: NavigationItem, index: number) => React.ReactChild[];
        render(): JSX.Element;
    }
}

declare module 'framer/types/src/components/Draggable' {
    import { Frame } from "framer/types/src/components/Frame";
    import { DraggableProps } from "framer/types/src/components/hoc/WithDragging";
    import { FrameProperties } from "framer/types/src/render";
    export const Draggable: React.ComponentClass<Partial<FrameProperties> & Partial<DraggableProps<typeof Frame>>>;
}

declare module 'framer/types/src/components/Page' {
    import * as React from "react";
    import { AnimatableObject } from "framer/types/src/animation/Animatable";
    import { InertialScroll, SpringOptions } from "framer/types/src/animation/Animators";
    import { MainLoopAnimationDriver } from "framer/types/src/animation/Drivers/MainLoopDriver";
    import { Rect } from "framer/types/src/render";
    import { FramerAnimation } from "framer/types/src/animation/FramerAnimation";
    export interface Props {
        parentSize: AnimatableObject<{
            width: number;
            height: number;
        }>;
    }
    export class Page extends React.Component<Props> {
        static _stylableContainer: boolean;
        static supportsConstraints: boolean;
        pages: Rect[];
        animation: FramerAnimation<number, SpringOptions> | null;
        nearestPageIndex: (position: number) => number;
        onDragAnimationStart: (animation: {
            x: MainLoopAnimationDriver<InertialScroll, number, any>;
            y: MainLoopAnimationDriver<InertialScroll, number, any>;
        }, draggable: any) => void;
        onDragSessionStart: () => void;
        render(): JSX.Element;
    }
}

declare module 'framer/types/src/components/Stack' {
    import * as React from "react";
    import { Layer, LayerProps } from "framer/types/src/render/presentation/Layer";
    import { FrameSpecificProps } from "framer/types/src/render/presentation/Frame";
    import { AnimatableObject, Cancel, Change } from "framer/types/src/animation/Animatable";
    import { ConstraintProperties } from "framer/types/src/render/types/Constraints";
    import { Rect } from "framer/types/src/render/types/Rect";
    import { Size } from "framer/types/src/render/types/Size";
    import { QualityOptions } from "framer/types/src/render/utils/imageForFill";
    import { WithFractionOfFreeSpace } from "framer/types/src/render/traits/FreeSpace";
    import { Point, PropertyControls, Line } from "framer/types/src/render";
    export type StackDirection = "horizontal" | "vertical";
    export type StackDistribution = "start" | "center" | "end" | "space-between" | "space-around" | "space-evenly";
    export type StackAlignment = "start" | "center" | "end";
    export interface StackPlaceHolders {
        index: number;
        sizes: Size[];
    }
    export interface StackSpecificProps {
        direction: StackDirection;
        distribution: StackDistribution;
        alignment: StackAlignment;
        gap: number;
        padding: number;
        paddingPerSide: boolean;
        paddingTop: number;
        paddingRight: number;
        paddingLeft: number;
        paddingBottom: number;
        placeholders?: StackPlaceHolders;
    }
    export interface StackProperties extends StackSpecificProps, FrameSpecificProps, LayerProps {
    }
    export interface StackState {
        size: AnimatableObject<Size> | Size | null;
        shouldCheckImageAvailability: boolean;
        currentBackgroundImageSrc: string | null;
    }
    export class Stack extends Layer<StackProperties, StackState> {
        static _stylableContainer: boolean;
        static defaultStackSpecificProps: StackSpecificProps;
        static defaultProps: StackProperties;
        static propertyControls: PropertyControls<StackProperties>;
        static rect(props: Partial<ConstraintProperties>, autoSize: Size | null): Rect;
        readonly rect: Rect;
        element: HTMLDivElement | null;
        imageDidChange: boolean;
        state: StackState;
        static getDerivedStateFromProps(nextProps: Partial<StackProperties>, prevState: StackState): StackState | null;
        static updatedSize(props: Partial<StackProperties>, state: StackState): AnimatableObject<Size> | Size;
        getStyle(size?: Size): React.CSSProperties;
        setElement: (element: HTMLDivElement | null) => void;
        propsObserver: AnimatableObject<StackProperties>;
        propsObserverCancel?: Cancel;
        sizeObserver: AnimatableObject<Size>;
        sizeObserverCancel?: Cancel;
        componentDidMount(): void;
        protected onPropsChange: (props: Change<AnimatableObject<StackProperties>>) => void;
        protected onSizeChange: () => void;
        componentWillUnmount(): void;
        checkImageAvailability: (qualityOptions: QualityOptions) => void;
        static minSize(props: StackProperties, parentSize: Size | AnimatableObject<Size> | null | undefined): Size;
        static size(props: StackProperties, parentSize: Size | AnimatableObject<Size> | null | undefined, freeSpace: WithFractionOfFreeSpace): Size;
        render(): JSX.Element | null;
        static paddingSize(props: StackProperties): {
            width: number;
            height: number;
        };
        static minChildrenSizes(children: React.ReactNode, size: Size, placeholders?: StackPlaceHolders): Size[];
        static childSizes(children: React.ReactNode, size: Size, freeSpace: WithFractionOfFreeSpace, placeholders?: StackPlaceHolders): Size[];
        static _cssExport(props: StackSpecificProps): React.CSSProperties;
        static childFractions(children: React.ReactNode): Size;
        static childLayoutRects(childSizes: Size[], size: Size, props: StackProperties, invisibleItems: number[]): Rect[];
        static autoSize(minChildrenSizes: Size[], props: StackProperties, invisibleItems: number[]): {
            width: number;
            height: number;
        };
        static freeSpace(size: Size, autoSize: Size, childFractions: Size, props: StackProperties): WithFractionOfFreeSpace;
        static invisibleItemIndexes(children: React.ReactNode, placeholders?: StackPlaceHolders): number[];
        static childInsertion(childRects: Rect[], containerSize: Size, insertion: Point, insertionMaxSize: Size, properties: StackProperties): {
            index: number;
            line: Line;
        };
    }
}

declare module 'framer/types/src/components/devices/DeviceRegisty' {
    import { Device } from "framer/types/src/components/devices/Device";
    import { ComponentDefinition } from "framer/types/src/render/utils/componentLoader";
    export type DevicesData = {
        devices: {
            [key: string]: ComponentDefinition;
        };
        deviceSkins: {
            [key: string]: ComponentDefinition;
        };
    };
    export class DeviceRegistry {
        resolve(identifier: string): typeof Device | undefined;
        list(): DevicesData;
    }
}

declare module 'framer/types/src/render/types/Size' {
    interface Size {
        width: number;
        height: number;
    }
    function Size(width: number, height: number): {
        width: number;
        height: number;
    };
    namespace Size {
        const equals: (sizeA: Size | null, sizeB: Size | null) => boolean;
        const update: (fromSize: Size, toSize: Partial<Size>, keepAspectRatio?: boolean) => {
            width: number;
            height: number;
        };
        function subtract(sizeA: Size, sizeB: Size): {
            width: number;
            height: number;
        };
        const zero: {
            width: number;
            height: number;
        };
        const isZero: (size: Size) => boolean;
        const defaultIfZero: (width: number, height: number, size: Size) => Size;
    }
    export { Size };
}

declare module 'framer/types/src/components/devices/DeviceRenderer' {
    import * as React from "react";
    import { DeviceSkin, DeviceHand } from "framer/types/src/components/devices/Device";
    import { Size } from "framer/types/src/render";
    export interface DeviceRendererProperties {
        skin: DeviceSkin | null;
        hand: DeviceHand | null;
        device: Size;
        screen: Size;
        content: Size;
        pixelRatio: number;
        rotate: boolean;
        responsive: boolean;
        svgScreenMask?: string;
    }
    export enum DeviceRendererMode {
        Canvas = 0,
        Screen = 1,
        Device = 2
    }
    export class DeviceRenderer extends React.Component<DeviceRendererProperties> {
        static defaultProps: DeviceRendererProperties;
        static getMode(props: DeviceRendererProperties): DeviceRendererMode;
        static getBackgroundColor(props: DeviceRendererProperties): string;
        getScreenStyle(screen: Size, device: Size, rotate: boolean, scale: number, svgScreenMask?: string): React.CSSProperties;
        render(): JSX.Element | JSX.Element[];
        renderCanvasMode(): JSX.Element;
        renderScreenOnly(): JSX.Element;
        renderSkinAndScreen(skin: DeviceSkin, hand: DeviceHand | null): JSX.Element[];
        calculateSkinRectAndScreenScale(skin: DeviceSkin, outerSize: Size, rotate: boolean): {
            width: number;
            height: number;
            left: number;
            top: number;
            scale: number;
        };
        calculateScreenRect(screen: Size, outerSize: Size, rotate: boolean, scale: number): {
            width: number;
            height: number;
            left: number;
            top: number;
        };
    }
}

declare module 'framer/types/src/components/devices/DeviceSkin' {
    import { WithPackage } from "framer/types/src/components/devices/WithPackage";
    export type DeviceSkins = {
        [key: string]: DeviceSkin | ExternalDeviceSkin;
    };
    export interface DeviceSkin {
        image: string;
        imageWidth: number;
        imageHeight: number;
        padding: number;
        background: string;
    }
    export type ExternalDeviceSkin = WithPackage & Partial<DeviceSkin>;
}

declare module 'framer/types/src/components/devices/DeviceHand' {
    import { WithPackage } from "framer/types/src/components/devices/WithPackage";
    export type DeviceHands = {
        [key: string]: DeviceHand | ExternalDeviceHand;
    };
    export type DeviceHand = {
        image: string;
        width: number;
        height: number;
        offset: number;
    };
    export type ExternalDeviceHand = WithPackage & Partial<DeviceHand>;
}

declare module 'framer/types/src/interpolation/Interpolation' {
    export type Interpolator<Value> = (progress: number) => Value;
    export interface Interpolation<Value = any> {
        interpolate(from: Value, to: Value): Interpolator<Value>;
        difference(from: Value, to: Value): number;
    }
    export interface Interpolatable<Value> {
        interpolationFor(value: Value, currentInterpolation: Interpolation): Interpolation<Value> | undefined;
    }
    export function isInterpolatable<Value>(value: any): value is Interpolatable<Value>;
    export namespace Interpolation {
        function handleUndefined<Value>(from: Value, to: Value): [Value, Value];
    }
}

declare module 'framer/types/src/interpolation/ValueInterpolation' {
    import { ColorMixModelType } from "framer/types/src/render/types/Color/types";
    import { Interpolation } from "framer/types/src/interpolation/Interpolation";
    export interface InterpolationOptions {
        colorModel: ColorMixModelType;
    }
    export class ValueInterpolation implements Interpolation {
        constructor(options?: Partial<InterpolationOptions>);
        protected interPolationForValue(value: any): Interpolation;
        interpolate: <T>(from: T, to: T) => (progress: number) => T;
        difference: <T>(from: T, to: T) => number;
    }
    export const AnyInterpolation: ValueInterpolation;
}

declare module 'framer/types/src/interpolation/NumberInterpolation' {
    import { Interpolation } from "framer/types/src/interpolation/Interpolation";
    export const NumberInterpolation: Interpolation<number>;
}

declare module 'framer/types/src/interpolation/ObjectInterpolation' {
    import { Interpolation } from "framer/types/src/interpolation/Interpolation";
    export const ObjectInterpolation: <Value, Type extends {
        [key: string]: Value;
    }>(valueInterpolation: Interpolation<Value>) => Interpolation<Type>;
}

declare module 'framer/types/src/interpolation/NoInterpolation' {
    import { Interpolation } from "framer/types/src/interpolation/Interpolation";
    export const NoInterpolation: Interpolation<any>;
}

declare module 'framer/types/src/interpolation/ColorInterpolation' {
    import { Interpolation } from "framer/types/src/interpolation/Interpolation";
    import { Color } from "framer/types/src/render/types/Color";
    import { ColorMixModelType } from "framer/types/src/render/types/Color/types";
    export const ColorInterpolation: (type?: ColorMixModelType) => Interpolation<Color>;
}

declare module 'framer/types/src/interpolation/transform' {
    import { Interpolation } from "framer/types/src/interpolation/Interpolation";
    import { ColorMixModelType } from "framer/types/src/render/types/Color/types";
    export function transform<InputValue, OutputValue>(from: [InputValue, InputValue], to: [OutputValue, OutputValue], options?: Partial<transform.Options<InputValue, OutputValue>>): (from: InputValue) => OutputValue;
    export namespace transform {
        interface Options<InputValue, OutputValue> {
            inputInterpolation: Interpolation<InputValue>;
            outputInterpolation: Interpolation<OutputValue>;
            limit: boolean;
            colorModel: ColorMixModelType;
        }
        function value<InputValue, OutputValue>(input: InputValue, from: [InputValue, InputValue], to: [OutputValue, OutputValue], options?: Partial<transform.Options<InputValue, OutputValue>>): OutputValue;
    }
}

declare module 'framer/types/src/render/types/Stroke' {
    export type LineJoin = "miter" | "round" | "bevel";
    export type LineCap = "butt" | "round" | "square";
}

declare module 'framer/types/src/render/utils/filtersForNode' {
    import { FilterProperties } from "framer/types/src/render/traits/Filters";
    import { BackgroundFilterProperties } from "framer/types/src/render/traits/BackdropFilters";
    export function collectLayerFilters(props: Partial<FilterProperties>, style: React.CSSProperties): void;
    export function collectBackgroundFilters(props: Partial<BackgroundFilterProperties>, style: React.CSSProperties): void;
    export function collectFiltersFromProps(props: Partial<FilterProperties & BackgroundFilterProperties>, style: React.CSSProperties): void;
}

declare module 'framer/types/src/render/utils/getURLs' {
    export function getURLs(): {
        imageBaseURL: string;
        projectURL: string;
    };
}

declare module 'framer/types/src/render/utils/serverURL' {
    export function serverURL(...paths: string[]): string;
}

declare module 'framer/types/src/utils/memoize' {
    export function memoize<K, V>(maxEntries: number, cache: Map<K, V>, key: K, create: (key: K) => V): V;
}

declare module 'framer/types/src/utils/internalId' {
    export class InternalID {
        id: string;
        constructor(id: string);
        add(str: string): InternalID;
        toString(): string;
        readonly link: string;
        readonly urlLink: string;
        static forKey(key: string): InternalID;
    }
}

declare module 'framer/types/src/render/utils/elementPropertiesForLinearGradient' {
    import { LinearGradient } from "framer/types/src/render/types/Gradient";
    export interface LinearGradientElementProperties {
        id: string;
        angle: number;
        startColor: string;
        startAlpha: number;
        stopColor: string;
        stopAlpha: number;
    }
    export function elementPropertiesForLinearGradient(gradient: LinearGradient, id: string): LinearGradientElementProperties;
}

declare module 'framer/types/src/render/utils/dom' {
    import { Rect } from "framer/types/src/render/types/Rect";
    import { Point } from "framer/types/src/render/types/Point";
    export const ready: (callback: Function) => void;
    export const frameFromElement: (element: Element) => Rect;
    export const frameFromElements: (elements: Element[]) => Rect;
    export const convertToPageFrame: (frame: Rect, element: Element) => Rect;
    export const convertFromPageFrame: (frame: Rect, element: Element) => Rect;
    export const getPageFrame: (element: Element) => Rect;
    export const fromEventForPage: (event: MouseEvent) => Point;
    export const fromEventForClient: (event: MouseEvent) => Point;
    export const convertToPagePoint: (point: Point, element: Element) => Point;
    export const convertFromPagePoint: (point: Point, element: Element) => Point;
    export const dispatchKeyDownEvent: (keyCode: number, options?: Partial<KeyboardEventInit & {
        keyIdentifier: string;
    }>) => void;
    export const DOM: {
        frameFromElement: (element: Element) => Rect;
        frameFromElements: (elements: Element[]) => Rect;
        convertToPageFrame: (frame: Rect, element: Element) => Rect;
        convertFromPageFrame: (frame: Rect, element: Element) => Rect;
        getPageFrame: (element: Element) => Rect;
        fromEventForPage: (event: MouseEvent) => Point;
        fromEventForClient: (event: MouseEvent) => Point;
        convertToPagePoint: (point: Point, element: Element) => Point;
        convertFromPagePoint: (point: Point, element: Element) => Point;
    };
}

declare module 'framer/types/src/render/traits/Fill' {
    import { Animatable } from "framer/types/src/animation/Animatable";
    import { Background } from "framer/types/src/render/traits/Background";
    export interface FillProperties {
        fill: Animatable<Background> | Background | null;
    }
}

declare module 'framer/types/src/render/traits/Filters' {
    import { Shadow } from "framer/types/src/render/types/Shadow";
    export interface FilterNumberProperties {
        brightness: number;
        contrast: number;
        grayscale: number;
        hueRotate: number;
        invert: number;
        saturate: number;
        sepia: number;
        blur: number;
    }
    export interface FilterProperties extends FilterNumberProperties {
        dropShadows: Shadow[];
    }
}

declare module 'framer/types/src/render/traits/BackdropFilters' {
    export interface BackgroundFilterProperties {
        backgroundBlur: number;
    }
}

declare module 'framer/types/src/render/traits/Radius' {
    import { Animatable } from "framer/types/src/animation/Animatable";
    export type RadiusValue = number | Animatable<number> | string;
    export interface RadiusProperties {
        radius: RadiusValue | Partial<{
            topLeft: RadiusValue;
            topRight: RadiusValue;
            bottomLeft: RadiusValue;
            bottomRight: RadiusValue;
        }>;
    }
    export function collectRadiusFromProps(props: Partial<RadiusProperties>, style: React.CSSProperties): void;
}

declare module 'framer/types/src/render/traits/Blending' {
    export interface BlendingProperties {
        blendingMode: BlendingMode;
    }
    export type BlendingMode = "normal" | "multiply" | "screen" | "overlay" | "darken" | "lighten" | "color-dodge" | "color-burn" | "hard-light" | "soft-light" | "difference" | "exclusion" | "hue" | "saturation" | "color" | "luminosity";
    export function collectBlendingFromProps(node: Partial<BlendingProperties>, style: React.CSSProperties): void;
}

declare module 'framer/types/src/render/traits/Background' {
    import { Gradient } from "framer/types/src/render/types/Gradient";
    import { Animatable } from "framer/types/src/animation/Animatable";
    import { Color } from "framer/types/src/render/types/Color";
    import { BackgroundImage } from "framer/types/src/render/types/BackgroundImage";
    export type Background = Color | Gradient | BackgroundImage | string;
    export interface BackgroundProperties {
        background: Animatable<Background> | Background | null;
    }
    export function collectBackgroundFromProps(props: Partial<BackgroundProperties>, style: React.CSSProperties): void;
}

declare module 'framer/types/src/render/types/BackgroundImage' {
    export { BackgroundImage };
    export type ImageFit = "fill" | "fit" | "stretch";
    interface BackgroundImage {
        src: string;
        pixelWidth?: number;
        pixelHeight?: number;
        intrinsicWidth?: number;
        intrinsicHeight?: number;
        fit?: ImageFit;
    }
    namespace BackgroundImage {
        const isImageObject: (image: any) => image is object & BackgroundImage;
    }
}

declare module 'framer/types/src/render/traits/Opacity' {
    import { Animatable } from "framer/types/src/animation/Animatable";
    export interface WithOpacity {
        opacity: number | Animatable<number>;
    }
    export function withOpacity(target: any): target is WithOpacity;
    export function collectOpacityFromProps(props: Partial<WithOpacity>, style: React.CSSProperties): void;
}

declare module 'framer/types/src/render/style/collectVisualStyleFromProps' {
    import { BackgroundProperties } from "framer/types/src/render/traits/Background";
    import { RadiusProperties } from "framer/types/src/render/traits/Radius";
    import { FilterProperties } from "framer/types/src/render/traits/Filters";
    import { BackgroundFilterProperties } from "framer/types/src/render/traits/BackdropFilters";
    import { BlendingProperties } from "framer/types/src/render/traits/Blending";
    import { OverflowProperties } from "framer/types/src/render/traits/Overflow";
    import { WithOpacity } from "framer/types/src/render/traits/Opacity";
    import { BoxShadowProperties } from "framer/types/src/render/traits/Shadow";
    import { TextColorProperties } from "framer/types/src/render/traits/TextColor";
    export type VisualProperties = Partial<BackgroundProperties & RadiusProperties & FilterProperties & BackgroundFilterProperties & BlendingProperties & OverflowProperties & BoxShadowProperties & WithOpacity & TextColorProperties>;
    export function collectVisualStyleFromProps(props: VisualProperties, style: React.CSSProperties, zoom: number): void;
}

declare module 'framer/types/src/render/traits/Shape' {
    import { WithPaths } from "framer/types/src/render/traits/Path";
    export interface WithShape {
        calculatedPaths(): WithPaths;
    }
    export function withShape(target: any): target is WithShape;
}

declare module 'framer/types/src/render/traits/BoxShadow' {
    import { BoxShadow } from "framer/types/src/render";
    export interface BoxShadowProperties {
        shadows: BoxShadow[];
    }
}

declare module 'framer/types/src/render/utils/gradientForShape' {
    import { WithShape } from "framer/types/src/render/traits/Shape";
    import { FillProperties } from "framer/types/src/render/traits/Fill";
    import { LinearGradientElementProperties } from "framer/types/src/render/utils/elementPropertiesForLinearGradient";
    export function gradientForShape(nodeId: string, node: WithShape & FillProperties): LinearGradientElementProperties | undefined;
}

declare module 'framer/types/src/render/utils/debounce' {
    export const debounce: <T extends (...args: any[]) => void>(fn: T, time: number) => T;
}

declare module 'framer/types/src/render/utils/imageForFill' {
    import { Rect } from "framer/types/src/render/types/Rect";
    import { RenderTarget } from "framer/types/src/render/types/RenderEnvironment";
    import { BackgroundImage, ImageFit } from "framer/types/src/render/types/BackgroundImage";
    export interface QualityOptions {
        frame: Rect;
        target: RenderTarget;
        zoom: number;
    }
    export function imageUrlForAsset(asset: string): string;
    export function imageUrlForFill(image: BackgroundImage, quality?: QualityOptions | null): string;
    export function setImageForFill(image: BackgroundImage, quality: QualityOptions | null, style: React.CSSProperties): void;
    export function _imageURL(asset: string | null, intrinsicWidth: number | null, intrinsicHeight: number | null, quality: QualityOptions | null, imageBaseURL: string): string;
    export function _imageScalingMethod(imageName: string | null, quality: QualityOptions | null, intrinsicWidth: number | null, intrinsicHeight: number | null, pixelWidth: number | null, pixelHeight: number | null, size?: ImageFit): "auto" | "pixelated";
}

declare module 'framer/types/src/render/utils/imagePatternPropsForFill' {
    import { Rect } from "framer/types/src/render/types/Rect";
    import { ImagePatternElementProperties } from "framer/types/src/render/presentation/ImagePatternElement";
    import { Background } from "framer/types/src/render/traits/Background";
    import { Animatable } from "framer/types/src/animation/Animatable/Animatable";
    export function imagePatternPropsForFill(fill: Background | Animatable<Background>, frame: Rect, id: string): ImagePatternElementProperties | undefined;
}

declare module 'framer/types/src/render/utils/componentLoader' {
    import { PropertyControls } from "framer/types/src/render/types/PropertyControls";
    import { JSONObject } from "framer/types/src/render/types/JSONData";
    import { Override } from "framer/types/src/data/WithOverride";
    export type PackageIdentifier = string;
    export type ComponentIdentifier = string;
    export type ComponentDefinition<P = any> = {
        file: string;
        packageIdentifier: string;
        identifier: ComponentIdentifier;
        name: string;
        type: ComponentType;
        external: boolean;
        class: React.ComponentType<P> | JSON | Override<any>;
        properties?: PropertyControls<P>;
        defaults?: P;
    };
    export type ErrorDefinition = {
        file: string;
        external: boolean;
        error: Error | string;
        fileDoesNotExist?: boolean;
    };
    export type ReactComponentDefinition<P = any> = ComponentDefinition<P> & {
        class: React.ComponentType<P>;
    };
    export type DesignComponentDefinition = ComponentDefinition & {
        class: JSONObject;
    };
    export function isReactDefinition<P = any>(d: ComponentDefinition<P>): d is ReactComponentDefinition<P>;
    export function isDesignDefinition(d: ComponentDefinition): d is DesignComponentDefinition;
    export function isNonUserFacing(d: ComponentDefinition): boolean;
    export function isOverride(d: ComponentDefinition): boolean;
    export function componentIdentifierForMasterId(masterid: string, packageName: string): string;
    export type ComponentType = "component" | "device" | "deviceSkin" | "deviceHand" | "master" | "override";
    export interface ComponentLoader {
        packageDisplayName(packageId: PackageIdentifier): string | undefined;
        localPackageIdentifier(): PackageIdentifier;
        packageIdentifiers(): PackageIdentifier[];
        componentsForPackage(identifier: string): ComponentDefinition[];
        componentForIdentifier(identifier: ComponentIdentifier): ComponentDefinition | null;
        errorForIdentifier(identifier: ComponentIdentifier): ErrorDefinition | null;
        componentIdentifiers(): ComponentIdentifier[];
        forEachDesignComponents(cb: (component: DesignComponentDefinition) => void): void;
        forEachComponent(cb: (component: ComponentDefinition) => boolean): void;
    }
    export const componentLoader: ComponentLoader;
    export const updateComponentLoader: (script: string, framer: any) => void;
    import * as React from "react";
    export const updateComponentLoaderWithScript: (script: string, framer: any) => void;
    export function findMasters(node: any, packageName: string, masters: any[]): void;
}

declare module 'framer/types/src/render/types/PropertyControls' {
    export type PropertyControls<P = any> = {
        [K in keyof P]?: ControlDescription<Partial<P>>;
    };
    export type ControlDescription<P = any> = BooleanControlDescription<P> | NumberControlDescription<P> | StringControlDescription<P> | FusedNumberControlDescription<P> | EnumControlDescription<P> | SegmentedEnumControlDescription<P> | ColorControlDescription<P> | ImageControlDescription<P> | FileControlDescription<P> | ChildrenControlDescription<P>;
    export const enum ControlType {
        Boolean = "boolean",
        Number = "number",
        String = "string",
        FusedNumber = "fusednumber",
        Enum = "enum",
        SegmentedEnum = "segmentedenum",
        Color = "color",
        Image = "image",
        File = "file",
        Children = "children"
    }
    export interface BaseControlDescription<P = any> {
        title?: string;
        hidden?: (props: P) => boolean;
    }
    export interface BooleanControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.Boolean;
        disabledTitle?: string;
        enabledTitle?: string;
    }
    export interface NumberControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.Number;
        max?: number;
        min?: number;
        unit?: string;
        step?: number;
    }
    export interface StringControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.String;
        placeholder?: string;
    }
    export interface FusedNumberControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.FusedNumber;
        toggleKey: keyof P;
        toggleTitles: [string, string];
        valueKeys: [keyof P, keyof P, keyof P, keyof P];
        valueLabels: [string, string, string, string];
        min?: number;
    }
    export interface DeprecatedFusedNumberControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.FusedNumber;
        valueKeys: [keyof P, keyof P, keyof P, keyof P];
        valueLabels: [string, string, string, string];
        min?: number;
        splitKey: keyof P;
        splitLabels: [string, string];
    }
    export interface EnumControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.Enum;
        options: string[];
        optionTitles?: string[];
    }
    export interface SegmentedEnumControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.SegmentedEnum;
        options: string[];
        optionTitles?: string[];
    }
    export interface ColorControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.Color;
    }
    export interface ImageControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.Image;
    }
    export interface FileControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.File;
        allowedFileTypes: string[];
    }
    export interface ChildrenControlDescription<P = any> extends BaseControlDescription<P> {
        type: ControlType.Children;
    }
    export function verifyPropertyControls(desc: object): PropertyControls<any>;
}

declare module 'framer/types/src/render/traits/FreeSpace' {
    import { Size } from "framer/types/src/render/types/Size";
    export interface WithFractionOfFreeSpace {
        freeSpaceInParent: Size;
        freeSpaceUnitDivisor: Size;
    }
    export function supportsFractionOfFreeSpace(obj: object): obj is object & WithFractionOfFreeSpace;
    export function freeSpaceFromProps(props: object): WithFractionOfFreeSpace | null;
}

declare module 'framer/types/src/render/traits/StylableContainer' {
    export interface WithStylable {
        _stylableContainer: boolean;
    }
    export function withStylableContainer(target: any): target is WithStylable;
}

declare module 'framer/types/src/render/utils/annotateTypeOnStringify' {
    export function annotateTypeOnStringify<T>(ctor: new (...args: any[]) => T, typeName: string): new (...args: any[]) => T;
    export function isOfAnnotatedType(object: any, typeName: string): boolean;
}

declare module 'framer/types/src/render/types/PathSegment' {
    import { PathSegmentRecord } from "framer/types/src/render/types/PathSegmentRecord";
    import { Point } from "framer/types/src/render";
    export namespace PathSegment {
        type HandleMirroring = "straight" | "symmetric" | "disconnected" | "asymmetric";
    }
    export class PathSegment extends PathSegmentRecord {
        x: number;
        y: number;
        handleMirroring: PathSegment.HandleMirroring;
        handleOutX: number;
        handleOutY: number;
        handleInX: number;
        handleInY: number;
        radius: number;
        toJS(): any;
        toJSON(): any;
    }
    export namespace PathSegment {
        const point: (pathSegment: PathSegment) => {
            x: number;
            y: number;
        };
        const handleOut: (pathSegment: PathSegment) => {
            x: number;
            y: number;
        };
        const handleIn: (pathSegment: PathSegment) => {
            x: number;
            y: number;
        };
        const calculatedHandleOut: (pathSegment: PathSegment) => Point;
        const calculatedHandleIn: (pathSegment: PathSegment) => Point;
        const curveDefault: (points: PathSegment[], index: number) => Point;
        const multiply: (segment: PathSegment, value: number) => PathSegment;
        const assymetricPoint: (opposite: Point, size: Point) => Point;
        const reflectAlongLine: (segment: PathSegment, lineStart: Point, lineEnd: Point) => PathSegment;
    }
}

declare module 'framer/types/src/render/types/PathSegments' {
    import { PathSegment } from "framer/types/src/render/types/PathSegment";
    export type PathSegments = {
        segments: PathSegment[];
        closed: boolean;
    };
}

declare module 'framer/types/src/render/traits/Path' {
    import { RenderTarget } from "framer/types/src/render";
    import { List } from "immutable";
    import { PathSegment } from "framer/types/src/render/types/PathSegment";
    export interface WithPath {
        pathSegments: List<PathSegment>;
        pathClosed: boolean;
    }
    export function withPath(target: any): target is WithPath;
    export type WithPaths = WithPath[];
    export const pathDefaults: WithPath;
    export function toSVGPath(withPaths: WithPaths | WithPath, translate?: {
        x: number;
        y: number;
    }, canvasMode?: RenderTarget): string;
    export function isStraightCurve(fromSegment: PathSegment, toSegment: PathSegment): boolean;
}

declare module 'framer/types/src/render/types/Shadow' {
    export interface Shadow {
        color: string;
        x: number;
        y: number;
        blur: number;
    }
    export namespace Shadow {
        function is(shadow: any): shadow is Shadow;
    }
    export interface BoxShadow {
        inset: boolean;
        color: string;
        x: number;
        y: number;
        blur: number;
        spread: number;
    }
    export namespace BoxShadow {
        function is(shadow: any): shadow is BoxShadow;
        function toCSS(shadow: BoxShadow): string;
    }
}

declare module 'framer/types/src/render/types/StrokeAlignment' {
    export type StrokeAlignment = "center" | "inside";
}

declare module 'framer/types/src/render/types/Rect' {
    import { Point } from "framer/types/src/render/types/Point";
    import { Size } from "framer/types/src/render/types/Size";
    export interface Rect extends Point, Size {
    }
    export namespace Rect {
        function equals(rect: Rect | null, other: Rect | null): boolean;
        const atOrigin: (size: Size) => {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        const fromTwoPoints: (a: Point, b: Point) => Rect;
        const fromRect: (rect: ClientRect) => Rect;
        const multiply: (rect: Rect, n: number) => Rect;
        const divide: (rect: Rect, n: number) => Rect;
        const offset: (rect: Rect, delta: Partial<Point>) => Rect;
        function inflate(rect: Rect, value: number): Rect;
        const pixelAligned: (rect: Rect) => Rect;
        const halfPixelAligned: (rect: Rect) => Rect;
        const round: (rect: Rect, decimals?: number) => Rect;
        const roundToOutside: (rect: Rect) => Rect;
        const minX: (rect: Rect) => number;
        const maxX: (rect: Rect) => number;
        const minY: (rect: Rect) => number;
        const maxY: (rect: Rect) => number;
        const positions: (rect: Rect) => {
            minX: number;
            midX: number;
            maxX: number;
            minY: number;
            midY: number;
            maxY: number;
        };
        const center: (rect: Rect) => {
            x: number;
            y: number;
        };
        const fromPoints: (ps: Point[]) => {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        const merge: (...rect: Rect[]) => Rect;
        const intersection: (rect1: Rect, rect2: Rect) => Rect;
        const points: (rect: Rect) => Point[];
        const containsPoint: (rect: Rect, point: Point) => boolean;
        const containsRect: (rectA: Rect, rectB: Rect) => boolean;
        const toCSS: (rect: Rect) => {
            display: string;
            transform: string;
            width: string;
            height: string;
        };
        const inset: (rect: Rect, n: number) => {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        const intersects: (rectA: Rect, rectB: Rect) => boolean;
        const overlapHorizontally: (rectA: Rect, rectB: Rect) => boolean;
        const overlapVertically: (rectA: Rect, rectB: Rect) => boolean;
        const doesNotIntersect: (rect: Rect, rects: Rect[]) => boolean;
        const isEqual: (rectA: Rect | null, rectB: Rect | null) => boolean;
        const cornerPoints: (rect: Rect) => Point[];
        const midPoints: (rect: Rect) => Point[];
        const pointDistance: (rect: Rect, point: Point) => number;
        const fromAny: (rect: any, defaults?: {
            x: number;
            y: number;
            width: number;
            height: number;
        }) => Rect;
    }
}

declare module 'framer/types/src/render/types/Line' {
    import { Point } from "framer/types/src/render";
    interface Line {
        a: Point;
        b: Point;
    }
    function Line(a: Point, b: Point): Line;
    namespace Line {
        function intersection(lineA: Line, lineB: Line): Point | null;
        const isOrthogonal: (line: Line) => boolean;
        const perpendicular: (line: Line, pointOnLine: Point) => Line;
        function projectPoint(line: Line, point: Point): Point | null;
    }
    export { Line };
}

declare module 'framer/types/src/render/types/Point' {
    interface Point {
        x: number;
        y: number;
    }
    function Point(x: number, y: number): Point;
    namespace Point {
        const add: (...args: Point[]) => Point;
        const subtract: (a: Point, b: Point) => Point;
        const multiply: (a: Point, b: number) => Point;
        const divide: (a: Point, b: number) => Point;
        const absolute: (point: Point) => Point;
        const reverse: (point: Point) => Point;
        const pixelAligned: (point: Point, offset?: Point) => Point;
        const distance: (a: Point, b: Point) => number;
        const angle: (a: Point, b: Point) => number;
        const isEqual: (a: Point, b: Point) => boolean;
        const rotationNormalizer: () => (value: number) => number;
        function center(a: Point, b: Point): {
            x: number;
            y: number;
        };
    }
    export { Point };
}

declare module 'framer/types/src/render/types/Gradient' {
    import { LinearGradient } from "framer/types/src/render/types/LinearGradient";
    import { RadialGradient } from "framer/types/src/render/types/RadialGradient";
    type Gradient = LinearGradient | RadialGradient;
    export { Gradient, LinearGradient, RadialGradient };
}

declare module 'framer/types/src/render/presentation/Frame' {
    import * as React from "react";
    import { Layer, LayerProps } from "framer/types/src/render/presentation/Layer";
    import { ConstraintProperties } from "framer/types/src/render/types/Constraints";
    import { BorderStyle } from "framer/types/src/render/style/border";
    import { Rect } from "framer/types/src/render/types/Rect";
    import { Size } from "framer/types/src/render/types/Size";
    import { QualityOptions } from "framer/types/src/render/utils/imageForFill";
    import { AnimatableObject, Change, Cancel } from "framer/types/src/animation/Animatable";
    import { WithFractionOfFreeSpace } from "framer/types/src/render/traits/FreeSpace";
    import { VisualProperties } from "framer/types/src/render/style/collectVisualStyleFromProps";
    import { TransformProperties } from "framer/types/src/render/traits/Transform";
    export interface FrameSpecificProps extends ConstraintProperties, TransformProperties, VisualProperties {
        visible: boolean;
        name?: string;
        borderWidth: number | Partial<{
            top: number;
            bottom: number;
            left: number;
            right: number;
        }>;
        borderColor: string;
        borderStyle: BorderStyle;
        style: React.CSSProperties;
        className?: string;
        _overrideForwardingDescription?: {
            [key: string]: string;
        };
    }
    export interface FrameState {
        size: AnimatableObject<Size> | Size | null;
        shouldCheckImageAvailability: boolean;
        currentBackgroundImageSrc: string | null;
    }
    export interface FrameProperties extends FrameSpecificProps, LayerProps {
    }
    export class Frame<Properties extends FrameProperties> extends Layer<FrameProperties, FrameState> {
        static supportsConstraints: boolean;
        static defaultFrameSpecificProps: FrameSpecificProps;
        static defaultProps: FrameProperties;
        static rect(props: Partial<ConstraintProperties>): Rect;
        readonly rect: Rect;
        static minSize(props: Partial<ConstraintProperties>, parentSize: Size | AnimatableObject<Size> | null | undefined): Size;
        static size(props: Partial<ConstraintProperties>, parentSize: Size | AnimatableObject<Size> | null | undefined, freeSpace: WithFractionOfFreeSpace): Size;
        element: HTMLDivElement | null;
        imageDidChange: boolean;
        state: FrameState;
        static getDerivedStateFromProps(nextProps: Partial<FrameProperties>, prevState: FrameState): FrameState | null;
        static updatedSize(props: Partial<FrameProperties>, state: FrameState): AnimatableObject<Size> | Size;
        getStyle(): React.CSSProperties;
        setElement: (element: HTMLDivElement | null) => void;
        propsObserver: AnimatableObject<FrameProperties>;
        propsObserverCancel?: Cancel;
        sizeObserver: AnimatableObject<Size>;
        sizeObserverCancel?: Cancel;
        componentDidMount(): void;
        protected onPropsChange: (props: Change<AnimatableObject<FrameProperties>>) => void;
        protected onSizeChange: () => void;
        componentWillUnmount(): void;
        checkImageAvailability: (qualityOptions: QualityOptions) => void;
        render(): JSX.Element | null;
        layoutChildren(): React.ReactChild[];
    }
    export const Center: React.SFC<{
        style?: React.CSSProperties;
    }>;
}

declare module 'framer/types/src/render/presentation/Layer' {
    import * as React from "react";
    export interface IdentityProps extends React.Props<any> {
        id?: string;
    }
    export interface LayerProps extends IdentityProps {
        willChangeTransform: boolean;
        _forwardedOverrides?: {
            [key: string]: any;
        };
    }
    export class Layer<P extends Partial<LayerProps>, S> extends React.Component<Partial<P>, S> {
        static defaultLayerProps: LayerProps;
        shouldComponentUpdate(nextProps: P, nextState: S): boolean;
        readonly properties: P;
        previousZoom: number;
        componentDidUpdate(prevProps: P): void;
        protected resetSetStyle(key: string, toValue: any | null, microtask?: boolean): void;
    }
}

declare module 'framer/types/src/render/presentation/SVG' {
    import { Layer, LayerProps } from "framer/types/src/render/presentation/Layer";
    import { ConstraintProperties, UserConstraintValues } from "framer/types/src/render/types/Constraints";
    import { Rect } from "framer/types/src/render/types/Rect";
    import { Shadow } from "framer/types/src/render/types/Shadow";
    import { Animatable, AnimatableObject } from "framer/types/src/animation/Animatable";
    import { Background, FilterProperties, BackgroundFilterProperties, RadiusProperties, WithOpacity, Size, WithFractionOfFreeSpace } from "framer/types/src/render";
    export interface SVGProps extends ConstraintProperties, Partial<FilterProperties & BackgroundFilterProperties & RadiusProperties & WithOpacity> {
        rotation: Animatable<number> | number;
        visible: boolean;
        name?: string;
        fill?: Animatable<Background> | Background | null;
        svg: string;
        intrinsicWidth?: number;
        intrinsicHeight?: number;
        shadows: Shadow[];
    }
    export interface SVGProperties extends SVGProps, LayerProps {
    }
    export class SVG extends Layer<SVGProperties, {}> {
        static supportsConstraints: boolean;
        static defaultSVGProps: SVGProps;
        static defaultProps: SVGProperties;
        static frame(props: Partial<ConstraintProperties>): Rect;
        readonly frame: Rect;
        static minSize(props: Partial<ConstraintProperties>, parentSize: Size | AnimatableObject<Size> | null | undefined): Size;
        static size(props: Partial<ConstraintProperties>, parentSize: Size | AnimatableObject<Size> | null | undefined, freeSpace: WithFractionOfFreeSpace): Size;
        constraintValues(): UserConstraintValues;
        componentDidUpdate(prevProps: SVGProperties): void;
        render(): JSX.Element | null;
    }
}

declare module 'framer/types/src/render/presentation/Text' {
    import * as React from "react";
    import { EditorState, ContentState, RawDraftContentState } from "draft-js";
    import { Layer, LayerProps } from "framer/types/src/render/presentation/Layer";
    import { ConstraintProperties, UserConstraintValues } from "framer/types/src/render/types/Constraints";
    import { Size } from "framer/types/src/render/types/Size";
    import { Rect } from "framer/types/src/render/types/Rect";
    import { FilterProperties } from "framer/types/src/render";
    import { Shadow } from "framer/types/src/render/types/Shadow";
    import { Animatable, AnimatableObject } from "framer/types/src/animation/Animatable";
    import { WithFractionOfFreeSpace } from "framer/types/src/render/traits/FreeSpace";
    export type TextAlignment = "left" | "right" | "center" | undefined;
    export interface TextProps extends ConstraintProperties, Partial<FilterProperties> {
        rotation: Animatable<number> | number;
        visible: boolean;
        name?: string;
        contentState?: ContentState;
        alignment: TextAlignment;
        autoSize: boolean;
        clip: boolean;
        size: Size;
        opacity?: number;
        shadows: Shadow[];
        style?: React.CSSProperties;
        text?: string;
        font?: string;
    }
    export interface TextProperties extends TextProps, LayerProps {
        rawHTML?: string;
    }
    export class Text extends Layer<TextProperties, {}> {
        static supportsConstraints: boolean;
        static defaultTextProps: TextProps;
        static defaultProps: TextProperties;
        editorText: string | undefined;
        editorState: EditorState | null;
        readonly frame: Rect;
        static minSize(props: Partial<ConstraintProperties>, parentSize: Size | AnimatableObject<Size> | null | undefined): Size;
        static size(props: Partial<ConstraintProperties>, parentSize: Size | AnimatableObject<Size> | null | undefined, freeSpace: WithFractionOfFreeSpace): Size;
        constraintValues(): UserConstraintValues;
        editorStateForContentState(contentState?: ContentState | RawDraftContentState): EditorState;
        componentWillReceiveProps(nextProps: TextProperties): void;
        render(): JSX.Element | null;
        onChange: (_: EditorState) => void;
    }
}

declare module 'framer/types/src/render/presentation/Vector' {
    import { Layer, LayerProps } from "framer/types/src/render/presentation/Layer";
    import { Rect } from "framer/types/src/render/types/Rect";
    import { StrokeAlignment } from "framer/types/src/render/types/StrokeAlignment";
    import { WithPath } from "framer/types/src/render/traits/Path";
    import { BoxShadow } from "framer/types/src/render/types/Shadow";
    import { LineCap, LineJoin } from "framer/types/src/render/types/Stroke";
    import { FillProperties } from "framer/types/src/render/traits/Fill";
    export interface VectorProps extends Partial<FillProperties> {
        isRootVectorNode: boolean;
        name: string | null;
        includeTransform?: boolean;
        defaultFillColor?: string;
        defaultStrokeColor?: string;
        defaultStrokeWidth?: number;
        defaultStrokeAlignment?: StrokeAlignment;
        width: number;
        height: number;
        rotation: number;
        frame: Rect;
        opacity?: number;
        calculatedPath: WithPath[];
        shapeId?: string;
        insideStroke: boolean;
        strokeEnabled: boolean;
        strokeClipId?: string;
        strokeWidth?: number;
        idAttribute?: string;
        shadows: BoxShadow[];
        rect: Rect;
        strokeAlpha: number;
        lineCap: LineCap;
        lineJoin: LineJoin;
        strokeColor: string;
        strokeMiterLimit: number;
        strokeDashArray: string;
        strokeDashOffset: number;
    }
    export interface VectorProperties extends VectorProps, LayerProps {
    }
    export class Vector extends Layer<VectorProperties, {}> {
        static defaultVectorProps: VectorProps;
        static defaultProps: VectorProperties;
        render(): JSX.Element | null;
        renderElement(element: JSX.Element): JSX.Element;
    }
}

declare module 'framer/types/src/render/presentation/VectorGroup' {
    import { LayerProps, Layer } from "framer/types/src/render/presentation/Layer";
    import { Rect } from "framer/types/src/render/types/Rect";
    export interface VectorGroupProps {
        name?: string;
        opacity?: number | string;
        visible: boolean;
        x: number;
        y: number;
        rotation: number;
        width: number;
        height: number;
        targetName?: string;
        defaultName: string;
        isRootVectorNode: boolean;
        frame: Rect;
        includeTransform?: boolean;
    }
    export interface VectorGroupProperties extends VectorGroupProps, LayerProps {
    }
    export class VectorGroup extends Layer<VectorGroupProperties, {}> {
        static defaultVectorGroupProps: VectorGroupProps;
        static defaultProps: VectorGroupProperties;
        render(): JSX.Element | null;
        renderElement(element: JSX.Element): JSX.Element;
    }
}

declare module 'framer/types/src/render/presentation/ComponentContainer' {
    import * as React from "react";
    import { Layer, LayerProps } from "framer/types/src/render/presentation/Layer";
    import { ConstraintProperties, UserConstraintValues } from "framer/types/src/render/types/Constraints";
    import { Rect } from "framer/types/src/render/types/Rect";
    import { Animatable, AnimatableObject } from "framer/types/src/animation/Animatable";
    import { Size } from "framer/types/src/render/types/Size";
    import { WithFractionOfFreeSpace } from "framer/types/src/render/traits/FreeSpace";
    import { Background } from "framer/types/src/render/traits/Background";
    import { FilterProperties } from "framer/types/src/render/traits/Filters";
    export interface ComponentContainerProps<Component extends React.Component> extends ConstraintProperties, Partial<FilterProperties> {
        rotation: Animatable<number> | number;
        opacity: number;
        visible: boolean;
        componentIdentifier: string;
        background: Background | null;
    }
    export interface ComponentContainerState {
        error: {
            name: string;
            message: string;
            componentStack: string[];
        } | null;
    }
    export interface ComponentContainerProperties extends ComponentContainerProps<any>, LayerProps {
    }
    export class ComponentContainer extends Layer<ComponentContainerProperties, ComponentContainerState> {
        static supportsConstraints: boolean;
        state: ComponentContainerState;
        static defaultComponentContainerProps: ComponentContainerProps<any>;
        static defaultProps: ComponentContainerProperties;
        static rect(props: Partial<ConstraintProperties>): Rect;
        readonly rect: Rect;
        static minSize(props: Partial<ConstraintProperties>, parentSize: Size | AnimatableObject<Size> | null | undefined): Size;
        static size(props: Partial<ConstraintProperties>, parentSize: Size | AnimatableObject<Size> | null | undefined, freeSpace: WithFractionOfFreeSpace): Size;
        componentDidCatch(error: Error, info: React.ErrorInfo): void;
        static getDerivedStateFromProps(nextProps: ComponentContainerProperties, prevState: ComponentContainerState): ComponentContainerState | null;
        constraintValues(): UserConstraintValues;
        render(): JSX.Element;
    }
}

declare module 'framer/types/src/render/presentation/TextBlock' {
    import * as React from "react";
    import { ContentState, ContentBlock } from "draft-js";
    export interface BlockProps {
        alignment?: "left" | "center" | "right";
    }
    export interface TextBlockProps {
        block: ContentBlock;
        contentState: ContentState;
        blockProps: BlockProps;
    }
    export class TextBlock extends React.Component<TextBlockProps, {}> {
        render(): JSX.Element;
    }
    export const draftBlockRendererFunction: (editable: boolean, alignment?: "left" | "right" | "center" | undefined) => (block: ContentBlock) => {
        component: typeof TextBlock;
        props: {
            alignment: "left" | "right" | "center" | undefined;
        };
        editable: boolean;
    };
}

declare module 'framer/types/src/render/types/TransformValues' {
    export type TransformValues = {
        x: number;
        y: number;
        rotation: number;
        width: number;
        height: number;
    };
}

declare module 'framer/types/src/render/types/Constraints' {
    import * as React from "react";
    import { Rect } from "framer/types/src/render/types/Rect";
    import { Size } from "framer/types/src/render/types/Size";
    import { Animatable, AnimatableObject } from "framer/types/src/animation/Animatable";
    import { WithFractionOfFreeSpace } from "framer/types/src/render/traits/FreeSpace";
    export interface DefaultProps {
        parentSize: AnimatableObject<Size>;
    }
    export interface ConstraintProperties extends Partial<WithFractionOfFreeSpace> {
        parentSize: Size | AnimatableObject<Size> | null;
        left: Animatable<number> | number | null;
        right: Animatable<number> | number | null;
        top: Animatable<number> | number | null;
        bottom: Animatable<number> | number | null;
        centerX: ConstraintPercentage;
        centerY: ConstraintPercentage;
        width: ConstraintDimension;
        height: ConstraintDimension;
        aspectRatio: number | null;
        autoSize?: boolean;
    }
    export const constraintDefaults: ConstraintProperties;
    export type ConstraintPercentage = string;
    export type ConstraintAuto = "auto";
    export type ConstraintFreespaceFraction = string;
    export type ConstraintDimension = Animatable<number> | number | ConstraintPercentage | ConstraintAuto | ConstraintFreespaceFraction;
    export enum DimensionType {
        FixedNumber = 0,
        Percentage = 1,
        Auto = 2,
        FractionOfFreeSpace = 3
    }
    export interface ConstraintMask {
        left: boolean;
        right: boolean;
        top: boolean;
        bottom: boolean;
        widthType: DimensionType;
        heightType: DimensionType;
        aspectRatio: number | null;
        fixedSize: boolean;
    }
    export function isConstraintSupportingChild<T extends ConstraintProperties>(child: React.ReactChild): child is React.ReactElement<T>;
    export function isConstraintSupportingClass<T extends ConstraintProperties>(classToTest: any): classToTest is React.ComponentClass<T>;
    export namespace ConstraintMask {
        const quickfix: (constraints: ConstraintMask) => ConstraintMask;
    }
    export interface ConstraintValuesBase {
        left: number | null;
        right: number | null;
        top: number | null;
        bottom: number | null;
        centerAnchorX: number;
        centerAnchorY: number;
        widthType: DimensionType;
        heightType: DimensionType;
        aspectRatio: number | null;
    }
    export interface ConstraintValues extends ConstraintValuesBase {
        width: number;
        height: number;
    }
    export interface UserConstraintValues extends ConstraintValuesBase {
        width: number | null;
        height: number | null;
    }
    export function valueToDimensionType(value: string | number | Animatable<number> | undefined): DimensionType;
    export namespace ConstraintValues {
        const fromProperties: (props: Partial<ConstraintProperties> & {
            autoSize?: boolean | undefined;
        }) => UserConstraintValues;
        const toMinSize: (values: UserConstraintValues, parentSize: Size | AnimatableObject<Size> | null | undefined, autoSize?: Size | null) => Size;
        const toSize: (values: UserConstraintValues, parentSize: Size | AnimatableObject<Size> | null | undefined, autoSize: Size | null, freeSpace: WithFractionOfFreeSpace | null) => Size;
        const toRect: (values: UserConstraintValues, parentSize: Size | AnimatableObject<Size> | null, autoSize?: Size | null, freeSpace?: WithFractionOfFreeSpace | null, pixelAlign?: boolean) => Rect;
    }
}

declare module 'framer/types/src/render/types/Color' {
    export { Color } from "framer/types/src/render/types/Color/Color";
    export { ConvertColor } from "framer/types/src/render/types/Color/ConvertColor";
}

declare module 'framer/types/src/render/style/border' {
    import * as React from "react";
    import { FrameProperties } from "framer/types/src/render/presentation/Frame";
    import { Rect } from "framer/types/src/render/types/Rect";
    export type BorderStyle = "solid" | "dashed" | "dotted" | "double";
    export function collectBorderStyleForProps(props: FrameProperties, rect: Rect, style: React.CSSProperties): void;
    export function borderForProps(props: FrameProperties, rect: Rect, borderRadius: number | string | undefined): JSX.Element | null;
}

declare module 'framer/types/src/render/style/draft' {
    import * as React from "react";
    import { OrderedSet } from "immutable";
    export const draftStyles: {
        font: {
            prefix: string;
            default: any;
            setCSS: typeof getStyleForTypefaceOrSelector;
            fromCSS: typeof getFontStyleStringFromCSS;
        };
        color: {
            prefix: string;
            default: string;
            setCSS: (value: string, css: React.CSSProperties) => string;
            fromCSS: (css: CSSStyleDeclaration) => string | undefined;
        };
        size: {
            prefix: string;
            default: number;
            setCSS: (value: string | number, css: React.CSSProperties) => string;
            fromCSS: (css: CSSStyleDeclaration) => string | undefined;
        };
        letterSpacing: {
            prefix: string;
            default: number;
            setCSS: (value: string | number, css: React.CSSProperties) => string;
            fromCSS: (css: CSSStyleDeclaration) => string | undefined;
        };
        lineHeight: {
            prefix: string;
            default: number;
            setCSS: (value: string | number, css: React.CSSProperties) => string;
            fromCSS: (css: CSSStyleDeclaration) => string | undefined;
        };
        align: {
            prefix: string;
        };
    };
    export const draftStyleFunction: (autoSize: boolean) => (styles: OrderedSet<string>, styleSelection?: boolean) => React.CSSProperties;
    export function getStyleForTypefaceOrSelector(value: string, css?: React.CSSProperties): React.CSSProperties;
    export function getFontStyleStringFromCSS(css: CSSStyleDeclaration): string | undefined;
}

declare module 'framer/types/src/render/utils/isEqual' {
    export function isEqual(a: any, b: any, deep?: boolean): boolean;
}

declare module 'framer/types/src/render/utils/isFiniteNumber' {
    export function isFiniteNumber(value: any): value is number;
    export function finiteNumber(value: any): number | undefined;
}

declare module 'framer/types/src/render/utils/roundedNumber' {
    export function roundedNumber(value: number, decimals: number): number;
    export function roundedNumberString(value: number, decimals: number): string;
    export function roundWithOffset(value: number, offset: number): number;
}

declare module 'framer/types/src/render/utils/transformString' {
    import { TransformValues } from "framer/types/src/render/types/TransformValues";
    export function transformString(transform: TransformValues | undefined): string | undefined;
}

declare module 'framer/types/src/render/style/shadow' {
    import * as React from "react";
    import { Rect } from "framer/types/src/render/types/Rect";
    import { Shadow, BoxShadow } from "framer/types/src/render/types/Shadow";
    import { RenderTarget } from "framer/types/src/render/types/RenderEnvironment";
    import { TextProperties } from "framer/types/src/render/presentation/Text";
    import { BoxShadowProperties } from "framer/types/src/render/traits/Shadow";
    import { InternalID } from "framer/types/src/utils/internalId";
    export function shadowsAsFilter(shadows: Shadow[]): string[];
    export function collectTextShadowsForProps(props: TextProperties, style: React.CSSProperties): void;
    export function collectBoxShadowsForProps(props: Partial<BoxShadowProperties>, style: React.CSSProperties): void;
    export function shadowForShape(boxShadows: BoxShadow[], rect: Rect, shapeId: InternalID, fillAlpha: number, strokeAlpha: number, strokeWidth: number | undefined, strokeClipId: InternalID, svgStrokeAttributes: React.SVGAttributes<SVGElement>, canvasZoom: number, renderTarget: RenderTarget): {
        definition: JSX.Element[];
        outsetElement: JSX.Element | null;
        insetElement: JSX.Element | null;
        needsStrokeClip: boolean;
    };
    export function localShadowFrame(shadow: BoxShadow | Shadow, frame: Rect, isSVG?: boolean): {
        x: number;
        y: number;
        width: number;
        height: number;
    } | null;
}

declare module 'framer/types/src/render/presentation/PresentationTree' {
    import * as React from "react";
    import { LayerProps, IdentityProps } from "framer/types/src/render/presentation/Layer";
    import { Rect } from "framer/types/src/render/types/Rect";
    import { Size } from "framer/types/src/render/types/Size";
    export interface WithParentSize {
        parentSize: Size | null;
    }
    export interface PresentationTreeCache {
        props: any | null;
        canvasZoom: number;
        willChangeTransform: boolean;
        reactElement: any | null;
        codeComponentPresentation: any | null;
        placeholders: {
            index: number;
            sizes: Size[];
        } | null;
    }
    export interface PresentationTree {
        rect(parentSize: Size | null): Rect;
        getProps(): IdentityProps;
        children?: PresentationTree[];
        cache: Partial<PresentationTreeCache>;
    }
    export function renderPresentationTree<P extends LayerProps>(node: PresentationTree, componentForNode: (node: PresentationTree) => React.ComponentType<P>): React.ReactNode;
    export function convertPresentationTree<C, P extends LayerProps>(node: PresentationTree, converter: (node: PresentationTree, children: C[] | undefined) => C, codeComponentStack?: string[]): C;
}

declare module 'framer/types/src/render/types/RenderEnvironment' {
    export enum RenderTarget {
        canvas = 0,
        export = 1,
        preview = 2
    }
    export interface RenderEnvironment {
        imageBaseURL: string;
        target: RenderTarget;
        zoom: number;
    }
    export const windowKey = "FramerRenderEnvironment";
    export const RenderEnvironment: RenderEnvironment;
    export function executeInRenderEnvironment<T>(customEnvironment: Partial<RenderEnvironment>, task: () => T): T;
    export function setGlobalRenderEnvironment(environment: Partial<RenderEnvironment>): void;
    export namespace RenderTarget {
        function current(): RenderTarget;
        function hasRestrictions(): boolean;
    }
}

declare module 'framer/types/src/render/types/NavigationLink' {
    export enum NavigateTo {
        Previous = "@Previous"
    }
    export type NavigationTarget = string | NavigateTo.Previous;
    export enum NavigationTransition {
        push = "push",
        instant = "instant",
        fade = "fade",
        modal = "modal",
        overlay = "overlay",
        flip = "flip"
    }
    export enum NavigationTransitionDirection {
        left = "left",
        right = "right",
        up = "up",
        down = "down"
    }
    export interface NavigationLink {
        navigationTarget: NavigationTarget;
        navigationTransition: NavigationTransition;
        navigationTransitionDirection: NavigationTransitionDirection;
    }
}

declare module 'framer/types/src/render/traits/ChildInsertion' {
    import { Rect, Point, Size, Line } from "framer/types/src/render";
    export interface WithChildInsertion<P = {}> {
        childInsertion: (childRects: Rect[], containerSize: Size, insertion: Point, insertionMaxSize: Size, properties: P) => {
            index: number;
            line: Line;
        };
    }
    export function withChildInsertion(target: any): target is WithChildInsertion;
}

declare module 'framer/types/src/render/traits/ChildLayoutProvider' {
    import { Size } from "framer/types/src/render/types/Size";
    import { Rect } from "framer/types/src/render/types/Rect";
    export interface ChildLayoutProvider {
        childLayoutRects: (childSizes: Size[], size: Size, props: any, invisibleItems: number[]) => Rect[];
    }
    export function providesChildLayout(node: any): node is ChildLayoutProvider;
}

declare module 'framer/types/src/render/traits/FreeSpaceProvider' {
    import { WithFractionOfFreeSpace } from "framer/types/src/render/traits/FreeSpace";
    import { Size } from "framer/types/src/render/types/Size";
    export interface FreeSpaceProvider {
        freeSpace(size: Size, autoSize: Size, childFractions: Size, props: any): WithFractionOfFreeSpace;
    }
    export function providesFreeSpace(node: any): node is FreeSpaceProvider;
    export function toFreeSpace(node: any, size: Size, autoSize: Size | null, childFractions: Size, props: any): WithFractionOfFreeSpace | null;
}

declare module 'framer/types/src/render/traits/AutoSize' {
    import { Size } from "framer/types/src/render/types/Size";
    export interface AutoSize {
        autoSize(minChildrenSizes: Size[], props: any, invisibleItems: number[]): Size;
    }
    export function hasAutoSize(node: any): node is AutoSize;
    export function toAutoSize(node: any, minChildrenSizes: Size[], props: any, invisibleItems: number[]): Size | null;
}

declare module 'framer/types/src/render/traits/CSSExport' {
    import * as React from "react";
    export interface WithCSSExport {
        _cssExport: (props: any) => React.CSSProperties;
    }
    export function withCSSExport(target: any): target is WithCSSExport;
}

declare module 'framer/types/src/render/traits/PaddingSize' {
    import { Size } from "framer/types/src/render/types/Size";
    export interface PaddingSizeProvider {
        paddingSize(props: any): Size;
    }
    export function providesPaddingSize(node: any): node is PaddingSizeProvider;
    export function toPaddingSize(node: any, props: any): Size;
}

declare module 'framer/types/src/render/config/fonts' {
    import { Map, OrderedMap } from "immutable";
    type Selector = string;
    type Weight = number | undefined;
    type Font = {
        selector: Selector;
        weight: Weight;
    };
    export const typefaceAliases: {
        "__SF-Compact-Display-Regular__": string;
        "__SF-Compact-Display-Ultralight__": string;
        "__SF-Compact-Display-Thin__": string;
        "__SF-Compact-Display-Light__": string;
        "__SF-Compact-Display-Medium__": string;
        "__SF-Compact-Display-Semibold__": string;
        "__SF-Compact-Display-Heavy__": string;
        "__SF-Compact-Display-Black__": string;
        "__SF-Compact-Display-Bold__": string;
        "__SF-UI-Text-Regular__": string;
        "__SF-UI-Text-Light__": string;
        "__SF-UI-Text-Medium__": string;
        "__SF-UI-Text-Semibold__": string;
        "__SF-UI-Text-Bold__": string;
        "__SF-UI-Text-Heavy__": string;
        "__SF-UI-Text-Italic__": string;
        "__SF-UI-Text-Light-Italic__": string;
        "__SF-UI-Text-Medium-Italic__": string;
        "__SF-UI-Text-Semibold-Italic__": string;
        "__SF-UI-Text-Bold-Italic__": string;
        "__SF-UI-Text-Heavy-Italic__": string;
        "__SF-Compact-Text-Regular__": string;
        "__SF-Compact-Text-Light__": string;
        "__SF-Compact-Text-Medium__": string;
        "__SF-Compact-Text-Semibold__": string;
        "__SF-Compact-Text-Bold__": string;
        "__SF-Compact-Text-Heavy__": string;
        "__SF-Compact-Text-Italic__": string;
        "__SF-Compact-Text-Light-Italic__": string;
        "__SF-Compact-Text-Medium-Italic__": string;
        "__SF-Compact-Text-Semibold-Italic__": string;
        "__SF-Compact-Text-Bold-Italic__": string;
        "__SF-Compact-Text-Heavy-Italic__": string;
        "__SF-UI-Display-Condensed-Regular__": string;
        "__SF-UI-Display-Condensed-Ultralight__": string;
        "__SF-UI-Display-Condensed-Thin__": string;
        "__SF-UI-Display-Condensed-Light__": string;
        "__SF-UI-Display-Condensed-Medium__": string;
        "__SF-UI-Display-Condensed-Semibold__": string;
        "__SF-UI-Display-Condensed-Bold__": string;
        "__SF-UI-Display-Condensed-Heavy__": string;
        "__SF-UI-Display-Condensed-Black__": string;
        "__SF-UI-Display-Regular__": string;
        "__SF-UI-Display-Ultralight__": string;
        "__SF-UI-Display-Thin__": string;
        "__SF-UI-Display-Light__": string;
        "__SF-UI-Display-Medium__": string;
        "__SF-UI-Display-Semibold__": string;
        "__SF-UI-Display-Bold__": string;
        "__SF-UI-Display-Heavy__": string;
        "__SF-UI-Display-Black__": string;
        "__SF-UI-Display-Italic": string;
        "__SF-UI-Display-Ultralight-Italic__": string;
        "__SF-UI-Display-Thin-Italic__": string;
        "__SF-UI-Display-Light-Italic__": string;
        "__SF-UI-Display-Medium-Italic__": string;
        "__SF-UI-Display-Semibold-Italic__": string;
        "__SF-UI-Display-Bold-Italic__": string;
        "__SF-UI-Display-Heavy-Italic__": string;
        "__SF-UI-Display-Black-Italic__": string;
        "__SF-UI-Text-Condensed-Regular__": string;
        "__SF-UI-Text-Condensed-Light__": string;
        "__SF-UI-Text-Condensed-Medium__": string;
        "__SF-UI-Text-Condensed-Semibold__": string;
        "__SF-UI-Text-Condensed-Bold__": string;
        "__SF-UI-Text-Condensed-Heavy__": string;
        "__SF-Compact-Rounded-Regular__": string;
        "__SF-Compact-Rounded-Ultralight__": string;
        "__SF-Compact-Rounded-Thin__": string;
        "__SF-Compact-Rounded-Light__": string;
        "__SF-Compact-Rounded-Medium__": string;
        "__SF-Compact-Rounded-Semibold__": string;
        "__SF-Compact-Rounded-Bold__": string;
        "__SF-Compact-Rounded-Heavy__": string;
        "__SF-Compact-Rounded-Black__": string;
    };
    export const typefaces: OrderedMap<string, OrderedMap<string, Font>>;
    export const defaultFontDescriptor: any;
    export const fontSelectors: Map<string, [string, string, number | undefined]>;
    export {};
}

declare module 'framer/types/src/render/DesignComponentWrapper' {
    import * as React from "react";
    import { PropertyControls, ConstraintProperties, Size, Rect, WithFractionOfFreeSpace } from "framer/types/src/render";
    import { ConstraintDimension } from "framer/types/src/render/types/Constraints";
    export type PropertyTree = {
        componentClass?: string;
        name?: string | null;
        children?: PropertyTree[];
        props?: any;
    };
    export class CanvasStore {
        canvas: PropertyTree;
        listeners: React.Component[];
        ids: string[];
        static __shared: CanvasStore | null;
        static shared(data?: PropertyTree): CanvasStore;
        updateNode(presentationNode: PropertyTree): void;
        setCanvas(canvas: PropertyTree): void;
        registerListener(listener: React.Component, idOrName: string): PropertyTree | null;
        removeListener(listener: React.Component): void;
    }
    export function hasSelfInParentChain(self: React.Component): boolean;
    export function freeSpaceFromProps(props: any): any | null;
    export function createDesignComponent<P>(canvas: CanvasStore, id: string, propertyControls: PropertyControls<P>, width?: ConstraintDimension, height?: ConstraintDimension): {
        new (props: P & Partial<ConstraintProperties>, context?: any): {
            checkedParent: boolean;
            parentError: boolean;
            hasParentError(): boolean;
            componentWillUnmount(): void;
            _typeForName(name: any): any;
            _createElement(type: any, props: any, children: any[]): React.ComponentElement<any, React.Component<any, React.ComponentState, any>>;
            _renderData(presentation: any, componentProps: any, topLevelProps?: any): React.ComponentElement<any, React.Component<any, React.ComponentState, any>> | null;
            render(): React.ComponentElement<any, React.Component<any, React.ComponentState, any>> | React.DetailedReactHTMLElement<{
                style: React.CSSProperties;
            }, HTMLElement> | null;
            setState<K extends "data">(state: {
                data: any;
            } | ((prevState: Readonly<{
                data: any;
            }>, props: P & Partial<ConstraintProperties>) => {
                data: any;
            } | Pick<{
                data: any;
            }, K> | null) | Pick<{
                data: any;
            }, K> | null, callback?: (() => void) | undefined): void;
            forceUpdate(callBack?: (() => void) | undefined): void;
            props: Readonly<{
                children?: React.ReactNode;
            }> & Readonly<P & Partial<ConstraintProperties>>;
            state: Readonly<{
                data: any;
            }>;
            context: any;
            refs: {
                [key: string]: React.ReactInstance;
            };
        };
        propertyControls: PropertyControls<P>;
        supportsConstraints: boolean;
        defaultProps: ConstraintProperties;
        rect(props: Partial<ConstraintProperties>): Rect;
        minSize(props: Partial<ConstraintProperties>, parentSize: any): Size;
        size(props: Partial<ConstraintProperties>, parentSize: any, freeSpace: WithFractionOfFreeSpace): Size;
    };
}

declare module 'framer/types/src/core/EventEmitter' {
    import { ListenerFn } from "eventemitter3";
    export class EventEmitter<EventName> {
        eventNames(): string[];
        eventListeners(): {
            [index: string]: ListenerFn[];
        };
        on(eventName: EventName, fn: Function): void;
        off(eventName: EventName, fn: Function): void;
        once(eventName: EventName, fn: Function): void;
        unique(eventName: EventName, fn: Function): void;
        addEventListener(eventName: EventName, fn: Function, once: boolean, unique: boolean, context: Object): void;
        removeEventListeners(eventName?: EventName, fn?: Function): void;
        removeAllEventListeners(): void;
        countEventListeners(eventName?: EventName, handler?: Function): number;
        emit(eventName: EventName, ...args: any[]): void;
    }
}

declare module 'framer/types/src/animation/Animators/Integrator' {
    export interface State {
        x: number;
        v: number;
    }
    export type AccelerationFunction = (state: State) => number;
    export class Integrator {
        constructor(accelerationFunction: AccelerationFunction);
        integrateState(state: State, dt: number): State;
    }
}

declare module 'framer/types/src/events/recognizer/TouchEventListener' {
    import * as React from "react";
    import { FramerEventSession } from "framer/types/src/events/FramerEventSession";
    export interface Props {
        session: FramerEventSession;
    }
    export class TouchEventListener extends React.Component<Props> {
        render(): React.ReactNode;
        componentDidMount(): void;
        componentWillUnmount(): void;
        domTouchStart: (originalEvent: TouchEvent) => void;
        domTouchMove: (originalEvent: TouchEvent) => void;
        domTouchEnd: (originalEvent: TouchEvent) => void;
    }
}

declare module 'framer/types/src/events/recognizer/MouseEventListener' {
    import * as React from "react";
    import { FramerEventSession } from "framer/types/src/events/FramerEventSession";
    export interface Props {
        session: FramerEventSession;
    }
    export class MouseEventListener extends React.Component<Props> {
        render(): React.ReactNode;
        componentDidMount(): void;
        componentWillUnmount(): void;
        domMouseDown: (originalEvent: MouseEvent) => void;
        domMouseMove: (originalEvent: MouseEvent) => void;
        domMouseUp: (originalEvent: MouseEvent) => void;
        domMouseWheel: (originalEvent: MouseEvent) => void;
    }
}

declare module 'framer/types/src/utils/events' {
    export interface EventLike {
        pageX: number;
        pageY: number;
        target: EventTarget | null;
    }
    export function pointForEvent(event: EventLike, customTarget?: EventTarget | null): {
        x: number;
        y: number;
    };
}

declare module 'framer/types/src/events/recognizer/GestureRecognizer' {
    import { FramerEvent } from "framer/types/src/events/FramerEvent";
    import { FramerEventSession } from "framer/types/src/events/FramerEventSession";
    export enum State {
        Possible = 2,
        Began = 4,
        Changed = 8,
        Ended = 16,
        Failed = 32,
        Cancelled = 64,
        Recognized = 128
    }
    export abstract class GestureRecognizer {
        readonly state: State;
        handler: GestureHandler | null;
        preventers: GestureRecognizer[];
        readonly isPrevented: boolean;
        abstract pointerSessionBegan(session: FramerEventSession, event: FramerEvent): void;
        abstract pointerSessionMoved(session: FramerEventSession, event: FramerEvent): void;
        abstract pointerSessionEnded(session: FramerEventSession, event: FramerEvent): void;
        canBePreventedBy(recognizer: GestureRecognizer): void;
        hasState(bitmask: State): boolean;
        stateSwitch(newState: State): void;
        cancel(): void;
        reset(): void;
    }
    export interface GestureHandler {
        gestureBegan: (type: string, event: FramerEvent, target: EventTarget | null) => void;
        gestureChanged: (type: string, event: FramerEvent, target: EventTarget | null) => void;
        gestureEnded: (type: string, event: FramerEvent, target: EventTarget | null) => void;
    }
}

declare module 'framer/types/src/events/recognizer/MouseWheelGestureRecognizer' {
    import { GestureRecognizer } from "framer/types/src/events/recognizer/GestureRecognizer";
    import { FramerEventSession } from "framer/types/src/events/FramerEventSession";
    import { FramerEvent } from "framer/types/src/events/FramerEvent";
    export class MouseWheelGestureRecognizer extends GestureRecognizer {
        readonly eventType: string;
        pointerSessionBegan(session: FramerEventSession, event: FramerEvent): void;
        pointerSessionMoved(session: FramerEventSession, event: FramerEvent): void;
        pointerSessionEnded(session: FramerEventSession, event: FramerEvent): void;
        mouseWheel(session: FramerEventSession, event: FramerEvent): void;
    }
}

declare module 'framer/types/src/components/hoc/WithEvents' {
    import * as React from "react";
    import { FramerEvent } from "framer/types/src/events/FramerEvent";
    export type EventHandler = (event: FramerEvent) => void;
    export interface WithPanHandlers {
        onPanStart: EventHandler;
        onPan: EventHandler;
        onPanEnd: EventHandler;
    }
    export interface WithTapHandlers {
        onTapStart: EventHandler;
        onTap: EventHandler;
        onTapEnd: EventHandler;
    }
    export interface WithMouseHandlers {
        onMouseDown: EventHandler;
        onClick: EventHandler;
        onMouseUp: EventHandler;
    }
    export interface WithMouseWheelHandler {
        onMouseWheelStart: EventHandler;
        onMouseWheel: EventHandler;
        onMouseWheelEnd: EventHandler;
    }
    export interface WithEventsProperties extends WithPanHandlers, WithTapHandlers, WithMouseHandlers, WithMouseWheelHandler {
    }
    export interface WithElement {
        element: HTMLElement | null;
    }
    export interface MayHaveStyle {
        style?: React.CSSProperties;
    }
    export function WithEvents<T, BaseProps extends React.ClassAttributes<T> & MayHaveStyle>(BaseComponent: React.ComponentType<BaseProps>): React.ComponentClass<BaseProps & Partial<WithEventsProperties>>;
}

declare module 'framer/types/src/components/hoc/WithDragging' {
    import * as React from "react";
    import { Point, Rect, ConstraintPercentage } from "framer/types/src/render";
    import { FramerEvent } from "framer/types/src/events/FramerEvent";
    import { WithPanHandlers, WithMouseWheelHandler } from "framer/types/src/components/hoc/WithEvents";
    import { InertialScrollAnimator } from "framer/types/src/animation/Animators/InertialScrollAnimator";
    import { Animatable } from "framer/types/src/animation/Animatable";
    import { MainLoopAnimationDriver } from "framer/types/src/animation/Drivers/MainLoopDriver";
    export const DraggingContext: React.Context<{
        dragging: boolean;
    }>;
    export type Axis = "x" | "y";
    export type Handler = () => void;
    export type DragHandler<Draggable> = (draggable: Draggable) => void;
    export type DragEventHandler<Draggable> = (event: FramerEvent, draggable: Draggable) => void;
    export type ScrollAnimation = MainLoopAnimationDriver<InertialScrollAnimator, number, any>;
    export interface DragEvents<Draggable> {
        onMove: (point: Point, draggable: Draggable) => void;
        onDragDirectionLockStart: (axis: Axis, draggable: Draggable) => void;
        onDragAnimationStart: (animation: {
            x: ScrollAnimation;
            y: ScrollAnimation;
        }, draggable: Draggable) => void;
        onDragAnimationEnd: (animation: {
            x: ScrollAnimation;
            y: ScrollAnimation;
        }, draggable: Draggable) => void;
        onDragSessionStart: DragEventHandler<Draggable>;
        onDragSessionMove: DragEventHandler<Draggable>;
        onDragSessionEnd: DragEventHandler<Draggable>;
        onDragStart: DragEventHandler<Draggable>;
        onDragWillMove: DragEventHandler<Draggable>;
        onDragDidMove: DragEventHandler<Draggable>;
        onDragEnd: DragEventHandler<Draggable>;
    }
    export interface DraggableProps<Draggable> extends Partial<DragEvents<Draggable>> {
        momentum: boolean;
        momentumOptions: {
            friction: number;
            tolerance: number;
        };
        momentumVelocityMultiplier: number;
        speedX: number;
        speedY: number;
        bounce: boolean;
        bounceOptions: {
            friction: number;
            tension: number;
            tolerance: number;
        };
        directionLock: boolean;
        directionLockThreshold: {
            x: number;
            y: number;
        };
        overdrag: boolean;
        overdragScale: number;
        pixelAlign: boolean;
        velocityTimeout: number;
        velocityScale: number;
        horizontal: boolean;
        vertical: boolean;
        enabled: boolean;
        constraints: Partial<Rect>;
        mouseWheel: boolean;
    }
    export interface WithDraggingComponentTypeConstraints extends WithPanHandlers, WithMouseWheelHandler {
        left: number | Animatable<number> | null;
        top: number | Animatable<number> | null;
        width: number | ConstraintPercentage | Animatable<number>;
        height: number | ConstraintPercentage | Animatable<number>;
    }
    export function WithDragging<TOriginalProps extends Partial<WithDraggingComponentTypeConstraints>>(Component: React.ComponentType<TOriginalProps>): React.ComponentClass<TOriginalProps & Partial<DraggableProps<any>>>;
}

declare module 'framer/types/src/components/NavigationTransitions' {
    import { FrameProperties, Size } from "framer/types/src/render";
    export interface NavigationTransition {
        fitWidth?: boolean;
        fitHeight?: boolean;
        transitionDuration?: number;
        overCurrentContext?: boolean;
        goBackOnTapOutside?: boolean;
        backdropColor?: string;
        inStart?(contextSize: Size, contentSize: Size): Partial<FrameProperties>;
        inEnd?(contextSize: Size, contentSize: Size): Partial<FrameProperties>;
        outEnd?(contextSize: Size, contentSize: Size): Partial<FrameProperties>;
    }
    export namespace Transition {
        const Fade: NavigationTransition;
        const PushLeft: NavigationTransition;
        const PushRight: NavigationTransition;
        const PushDown: NavigationTransition;
        const PushUp: NavigationTransition;
        const Instant: NavigationTransition;
        const Modal: NavigationTransition;
        const OverlayTop: NavigationTransition;
        const OverlayBottom: NavigationTransition;
        const OverlayLeft: NavigationTransition;
        const OverlayRight: NavigationTransition;
        const FlipLeft: NavigationTransition;
        const FlipRight: NavigationTransition;
        const FlipDown: NavigationTransition;
        const FlipUp: NavigationTransition;
    }
}

declare module 'framer/types/src/animation/Drivers/MainLoopDriver' {
    import { Animator as AnimatorInterface } from "framer/types/src/animation/Animators/Animator";
    import { AnimationDriver } from "framer/types/src/animation/Drivers/AnimationDriver";
    export class MainLoopAnimationDriver<Animator extends AnimatorInterface<Value, Options>, Value, Options> extends AnimationDriver<Animator, Value, Options> {
        play(): void;
        cancel(): void;
        finish(): void;
    }
}

declare module 'framer/types/src/components/devices/WithPackage' {
    export interface WithPackage {
        package: string;
    }
    export function isWithPackage(target: any): target is WithPackage;
}

declare module 'framer/types/src/render/types/Color/types' {
    export enum ColorFormat {
        RGB = "rgb",
        HSL = "hsl",
        HSV = "hsv",
        HEX = "hex",
        NAME = "name"
    }
    export interface ColorRGB {
        r: number;
        g: number;
        b: number;
    }
    export type ColorRGBA = ColorRGB & {
        a: number;
    };
    export type ColorTypeRGBA = ColorRGBA & {
        format: ColorFormat;
    };
    export interface ColorHSL {
        h: number;
        s: number;
        l: number;
    }
    export type ColorHSLA = ColorHSL & {
        a: number;
    };
    export type ColorTypeHSLA = ColorHSLA & {
        format: ColorFormat;
    };
    export interface ColorHSV {
        h: number;
        s: number;
        v: number;
    }
    export type ColorHSVA = ColorHSV & {
        a: number;
    };
    export type ColorTypeHSVA = ColorHSVA & {
        format: ColorFormat;
    };
    export interface CompleteColor {
        format: ColorFormat;
        r: number;
        g: number;
        b: number;
        h: number;
        s: number;
        l: number;
        a: number;
    }
    export type IncomingColor = ColorRGB | ColorHSL | ColorRGBA | ColorHSLA | string;
    export enum ColorMixModelType {
        RGB = "rgb",
        RGBA = "rgba",
        HSL = "hsl",
        HSLA = "hsla",
        HUSL = "husl"
    }
}

declare module 'framer/types/src/render/traits/Overflow' {
    export type Overflow = "visible" | "hidden" | "scroll" | "auto";
    export interface OverflowProperties {
        overflow: Overflow;
    }
    export function collectOverflowFromProps(props: Partial<OverflowProperties>, style: React.CSSProperties): void;
}

declare module 'framer/types/src/render/traits/Shadow' {
    import { BoxShadow } from "framer/types/src/render/types/Shadow";
    export interface BoxShadowProperties {
        shadows: BoxShadow[];
    }
}

declare module 'framer/types/src/render/traits/TextColor' {
    import { Color } from "framer/types/src/render/types/Color";
    export interface TextColorProperties {
        color: Color | string;
    }
    export function collectTextColorFromProps(props: Partial<TextColorProperties>, style: React.CSSProperties): void;
}

declare module 'framer/types/src/render/presentation/ImagePatternElement' {
    import * as React from "react";
    export interface ImagePatternElementProperties {
        id: string;
        path: string;
        transform?: string;
    }
    export class ImagePatternElement extends React.Component<ImagePatternElementProperties, {}> {
        render(): JSX.Element;
    }
}

declare module 'framer/types/src/render/types/JSONData' {
    export type JSONObject = {
        [key: string]: JSONData;
    };
    export interface JSONArray extends Array<JSONData> {
    }
    export type JSONData = null | string | number | boolean | JSONArray | JSONObject;
}

declare module 'framer/types/src/render/types/PathSegmentRecord' {
    import { Record } from "immutable";
    export const PathSegmentRecord: Record.Class;
}

declare module 'framer/types/src/render/types/LinearGradient' {
    export interface LinearGradient {
        alpha: number;
        angle: number;
        start: string;
        end: string;
    }
    export namespace LinearGradient {
        function isLinearGradient(linearGradient: any): linearGradient is LinearGradient;
        function hash(linearGradient: LinearGradient): number;
        function toCSS(linearGradient: LinearGradient, overrideAngle?: number): string;
    }
}

declare module 'framer/types/src/render/types/RadialGradient' {
    export interface RadialGradient {
        alpha: number;
        widthFactor: number;
        heightFactor: number;
        centerAnchorX: number;
        centerAnchorY: number;
        start: string;
        end: string;
    }
    export namespace RadialGradient {
        function isRadialGradient(radialGradient: any): radialGradient is RadialGradient;
        function toCSS(radialGradient: RadialGradient): string;
    }
}

declare module 'framer/types/src/render/traits/Transform' {
    import { Animatable } from "framer/types/src/animation/Animatable";
    import { Rect } from "framer/types/src/render/types/Rect";
    export interface TransformProperties {
        z: Animatable<number> | number;
        rotation: Animatable<number> | number;
        rotationX: Animatable<number> | number;
        rotationY: Animatable<number> | number;
        rotationZ: Animatable<number> | number;
        scale: Animatable<number> | number;
        scaleX: Animatable<number> | number;
        scaleY: Animatable<number> | number;
        scaleZ: Animatable<number> | number;
        skew: Animatable<number> | number;
        skewX: Animatable<number> | number;
        skewY: Animatable<number> | number;
        originX: Animatable<number> | number;
        originY: Animatable<number> | number;
        originZ: Animatable<number> | number;
    }
    export const transformDefaults: TransformProperties;
    export function collectTransformFromProps(props: TransformProperties, rect: Rect, style: React.CSSProperties): void;
}

declare module 'framer/types/src/render/types/Color/Color' {
    import { IncomingColor, ColorHSL, ColorHSLA, ColorRGBA, ColorHSVA, ColorFormat, ColorMixModelType } from "framer/types/src/render/types/Color/types";
    export { Color };
    interface Color {
        r: number;
        g: number;
        b: number;
        h: number;
        s: number;
        l: number;
        a: number;
        roundA: number;
        format: ColorFormat;
        initialValue?: string;
        isValid?: boolean;
    }
    function Color(color: IncomingColor | Color | number, r?: number, g?: number, b?: number): Color;
    namespace Color {
        const inspect: (color: Color, initialValue?: string | undefined) => string;
        const isColorObject: (color: any) => color is object & Color;
        const toString: (color: Color) => string;
        const toHex: (color: Color, allow3Char?: boolean) => string;
        const toHexString: (color: Color, allow3Char?: boolean) => string;
        const toRgbString: (color: Color) => string;
        const toHusl: (color: Color) => ColorHSLA;
        const toHslString: (color: Color) => string;
        const toHsv: (color: Color) => ColorHSVA;
        const toHsvString: (color: Color) => string;
        const toName: (color: Color) => string | false;
        const toHsl: (color: Color) => ColorHSLA;
        const toRgb: (color: Color) => ColorRGBA;
        const brighten: (color: Color, amount?: number) => Color;
        const lighten: (color: Color, amount?: number) => Color;
        const darken: (color: Color, amount?: number) => Color;
        const desaturate: (color: Color, amount?: number) => Color;
        const grayscale: (color: Color) => Color;
        const saturate: (color: Color, amount?: number) => Color;
        const hueRotate: (color: Color, angle: number) => Color;
        const alpha: (color: Color, a?: number) => Color;
        const transparent: (color: Color) => Color;
        const multiplyAlpha: (color: Color, a?: number) => Color;
        const interpolate: (colorA: Color, colorB: Color, model?: ColorMixModelType) => (progress: number) => Color;
        const isColorString: (colorString: string | object) => boolean;
        const mix: (colorA: Color, colorB: Color, fraction?: number, limit?: boolean, model?: ColorMixModelType) => Color | null;
        const random: (a?: number) => Color;
        const grey: (g?: number, a?: number) => Color;
        const gray: (g?: number, a?: number) => Color;
        const isColor: (color: string | Color) => boolean;
        const rgbToHsl: (r: number, g: number, b: number) => ColorHSL;
        const isValidColorProperty: (name: string, value: string) => boolean;
        const difference: (colorA: Color, colorB: Color) => number;
        const equal: (colorA: Color, colorB: Color, tolerance?: number) => boolean;
    }
}

declare module 'framer/types/src/render/types/Color/ConvertColor' {
    import { Color } from "framer/types/src/render/types/Color/Color";
    import { ColorHSV, ColorHSVA, ColorRGB, ColorRGBA, ColorHSLA } from "framer/types/src/render/types/Color/types";
    export namespace ConvertColor {
        function hueRotate(color: string, angle: number): string;
        function setAlpha(color: string, alpha: number): string;
        function getAlpha(color: string): number;
        function multiplyAlpha(color: string, alpha: number): string;
        function toHex(color: string): string;
        function toRgb(color: string): ColorRGBA;
        function toRgbString(color: string): string;
        function toHSV(color: string): ColorHSVA;
        function toHSL(color: string): ColorHSLA;
        function toHsvString(color: string): string;
        function hsvToHSLString(hsv: ColorHSV | ColorHSVA): string;
        function hsvToString(hsv: ColorHSV | ColorHSVA): string;
        function rgbaToString(color: ColorRGB | ColorRGBA): string;
        function toColorPickerSquare(h: number): string;
        function isValid(color: string): boolean;
        function equals(a: Color | string, b: Color | string): boolean;
        function toHexOrRgbaString(input: string): string;
    }
}

declare module "framer/resource" {
    export function url(...src: string[]): string
}
